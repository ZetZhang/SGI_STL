!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
INITIAL_MAP_SIZE	contains/deque.hpp	/^#define INITIAL_MAP_SIZE /;"	d
INT	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT(int i) : m_i(i) {};$/;"	f	class:INT	file:	access:public	signature:(int i)
INT	confusing_syntax/indecrement_operator_overloading.cpp	/^class INT$/;"	c	file:
INT::INT	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT(int i) : m_i(i) {};$/;"	f	class:INT	file:	access:public	signature:(int i)
INT::m_i	confusing_syntax/indecrement_operator_overloading.cpp	/^    int m_i;$/;"	m	class:INT	typeref:typename:int	file:	access:private
INT::operator *	confusing_syntax/indecrement_operator_overloading.cpp	/^    int& operator*() const$/;"	f	class:INT	typeref:typename:int &	file:	access:public	signature:() const
INT::operator ++	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT& operator++()           \/\/ ++INT$/;"	f	class:INT	typeref:typename:INT &	file:	access:public	signature:()
INT::operator ++	confusing_syntax/indecrement_operator_overloading.cpp	/^    const INT operator++(int)   \/\/ INT++$/;"	f	class:INT	typeref:typename:const INT	file:	access:public	signature:(int)
INT::operator --	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT& operator--()           \/\/ --INT$/;"	f	class:INT	typeref:typename:INT &	file:	access:public	signature:()
INT::operator --	confusing_syntax/indecrement_operator_overloading.cpp	/^    const INT operator--(int)   \/\/ INT--$/;"	f	class:INT	typeref:typename:const INT	file:	access:public	signature:(int)
JJ	allocator/jj_allocator.hpp	/^namespace JJ$/;"	n
JJ::_allocate	allocator/jj_allocator.hpp	/^inline T* _allocate(std::ptrdiff_t size, T*)$/;"	f	namespace:JJ	typeref:typename:T *	signature:(std::ptrdiff_t size,T *)
JJ::_construct	allocator/jj_allocator.hpp	/^inline void _construct(T1 *p, const T2 &value)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T1 * p,const T2 & value)
JJ::_deallocate	allocator/jj_allocator.hpp	/^inline void _deallocate(T *buffer)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T * buffer)
JJ::_destroy	allocator/jj_allocator.hpp	/^inline void _destroy(T *ptr)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T * ptr)
JJ::allocator	allocator/jj_allocator.hpp	/^class allocator$/;"	c	namespace:JJ
JJ::allocator::address	allocator/jj_allocator.hpp	/^    pointer address(reference x)$/;"	f	class:JJ::allocator	typeref:typename:pointer	access:public	signature:(reference x)
JJ::allocator::allocate	allocator/jj_allocator.hpp	/^    pointer allocate(size_type n, const void *hint = 0)$/;"	f	class:JJ::allocator	typeref:typename:pointer	access:public	signature:(size_type n,const void * hint=0)
JJ::allocator::const_address	allocator/jj_allocator.hpp	/^    const_pointer const_address(const_reference x)$/;"	f	class:JJ::allocator	typeref:typename:const_pointer	access:public	signature:(const_reference x)
JJ::allocator::const_pointer	allocator/jj_allocator.hpp	/^    typedef const T*        const_pointer;$/;"	t	class:JJ::allocator	typeref:typename:const T *	access:public
JJ::allocator::const_reference	allocator/jj_allocator.hpp	/^    typedef const T&        const_reference;$/;"	t	class:JJ::allocator	typeref:typename:const T &	access:public
JJ::allocator::construct	allocator/jj_allocator.hpp	/^    void construct(pointer p, const T &value)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p,const T & value)
JJ::allocator::deallocate	allocator/jj_allocator.hpp	/^    void deallocate(pointer p, size_type n)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p,size_type n)
JJ::allocator::destroy	allocator/jj_allocator.hpp	/^    void destroy(pointer p)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p)
JJ::allocator::difference_type	allocator/jj_allocator.hpp	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:JJ::allocator	typeref:typename:std::ptrdiff_t	access:public
JJ::allocator::max_size	allocator/jj_allocator.hpp	/^    size_type max_size() const$/;"	f	class:JJ::allocator	typeref:typename:size_type	access:public	signature:() const
JJ::allocator::pointer	allocator/jj_allocator.hpp	/^    typedef T*              pointer;$/;"	t	class:JJ::allocator	typeref:typename:T *	access:public
JJ::allocator::rebind	allocator/jj_allocator.hpp	/^    struct rebind$/;"	s	class:JJ::allocator	access:public
JJ::allocator::rebind::other	allocator/jj_allocator.hpp	/^        typedef allocator<U> other;$/;"	t	struct:JJ::allocator::rebind	typeref:typename:allocator<U>	access:public
JJ::allocator::reference	allocator/jj_allocator.hpp	/^    typedef T&              reference;$/;"	t	class:JJ::allocator	typeref:typename:T &	access:public
JJ::allocator::size_type	allocator/jj_allocator.hpp	/^    typedef std::size_t     size_type;$/;"	t	class:JJ::allocator	typeref:typename:std::size_t	access:public
JJ::allocator::value_type	allocator/jj_allocator.hpp	/^    typedef T               value_type;$/;"	t	class:JJ::allocator	typeref:typename:T	access:public
JJ::whatthefuck	allocator/jj_allocator.hpp	/^void whatthefuck()$/;"	f	namespace:JJ	typeref:typename:void	signature:()
MyIter	allocator/test.cpp	/^    MyIter(T *p) : ptr(p) {}$/;"	f	struct:MyIter	file:	access:public	signature:(T * p)
MyIter	allocator/test.cpp	/^struct MyIter {$/;"	s	file:
MyIter::MyIter	allocator/test.cpp	/^    MyIter(T *p) : ptr(p) {}$/;"	f	struct:MyIter	file:	access:public	signature:(T * p)
MyIter::operator *	allocator/test.cpp	/^    T& operator*() { return *ptr; }$/;"	f	struct:MyIter	typeref:typename:T &	file:	access:public	signature:()
MyIter::ptr	allocator/test.cpp	/^    T *ptr;$/;"	m	struct:MyIter	typeref:typename:T *	file:	access:public
MyIter::value_type	allocator/test.cpp	/^    typedef T value_type;$/;"	t	struct:MyIter	typeref:typename:T	file:	access:public
__ALGORITHM_HPP__	contains/algorithm.hpp	/^#define __ALGORITHM_HPP__$/;"	d
__ALIGN	allocator/alloc.hpp	/^enum { __ALIGN = 8 };$/;"	e	enum:ich::__anon22e991b60103	access:public
__ALLOCATOR_HPP__	allocator/allocator.hpp	/^#define __ALLOCATOR_HPP__$/;"	d
__ALLOC_HPP__	allocator/alloc.hpp	/^#define __ALLOC_HPP__$/;"	d
__CONSTRUCTOR_HPP__	allocator/constructor.hpp	/^#define __CONSTRUCTOR_HPP__$/;"	d
__DEQUE_HPP__	contains/deque.hpp	/^#define __DEQUE_HPP__$/;"	d
__HASHTABLE_HPP__	contains/hashtable.hpp	/^#define __HASHTABLE_HPP__$/;"	d
__HASH_FUN_HPP__	contains/hash_fun.hpp	/^#define __HASH_FUN_HPP__$/;"	d
__ITERATOR_HPP__	allocator/iterator.hpp	/^#define __ITERATOR_HPP__$/;"	d
__JJ_ALLOC_HPP__	allocator/jj_allocator.hpp	/^#define __JJ_ALLOC_HPP__$/;"	d
__LIST_HPP__	contains/list.hpp	/^#define __LIST_HPP__$/;"	d
__LIST_HPP__	contains/list_temp.hpp	/^#define __LIST_HPP__$/;"	d
__MAP_HPP__	contains/map.hpp	/^#define __MAP_HPP__$/;"	d
__MAX_BYTES	allocator/alloc.hpp	/^enum { __MAX_BYTES = 128 };$/;"	e	enum:ich::__anon22e991b60203	access:public
__MULTImultimap_HPP__	contains/multimap.hpp	/^#define __MULTImultimap_HPP__$/;"	d
__MULTImultiset_HPP__	contains/multiset.hpp	/^#define __MULTImultiset_HPP__$/;"	d
__NFREELISTS	allocator/alloc.hpp	/^enum { __NFREELISTS = __MAX_BYTES \/ __ALIGN };$/;"	e	enum:ich::__anon22e991b60303	access:public
__NODE_ALLOCATOR_THREADS	allocator/alloc.hpp	/^#define __NODE_ALLOCATOR_THREADS /;"	d
__PAIR_HPP__	contains/pair.hpp	/^#define __PAIR_HPP__$/;"	d
__PRIORITY_QUEUE_HPP__	contains/priority_queue.hpp	/^#define __PRIORITY_QUEUE_HPP__$/;"	d
__QUEUE_HPP__	contains/queue.hpp	/^#define __QUEUE_HPP__$/;"	d
__RB_TREE_HPP__	contains/rb_tree.hpp	/^#define __RB_TREE_HPP__$/;"	d
__SET_HPP__	contains/set.hpp	/^#define __SET_HPP__$/;"	d
__SLIST_HPP__	contains/slist.hpp	/^#define __SLIST_HPP__$/;"	d
__STACK_HPP__	contains/stack.hpp	/^#define __STACK_HPP__$/;"	d
__STD_ALLOCATOR_HPP__	allocator/std_allocator.hpp	/^#define __STD_ALLOCATOR_HPP__$/;"	d
__THROW_BAD_ALLOC	allocator/alloc.hpp	/^#define __THROW_BAD_ALLOC /;"	d
__UNINITIALIZED_HPP__	allocator/uninitialized.hpp	/^#define __UNINITIALIZED_HPP__$/;"	d
__VECTOR_HPP__	contains/vector.hpp	/^#define __VECTOR_HPP__$/;"	d
____TYPE_TRAITS_HPP__	allocator/__type_traits.hpp	/^#define ____TYPE_TRAITS_HPP__$/;"	d
__adjust_heap	contains/algorithm.hpp	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance len,T value)
__adjust_heap	contains/algorithm.hpp	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value, Compar/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance len,T value,Compare comp)
__advance	allocator/iterator.hpp	/^inline void __advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(BidirectionalIterator & i,Distance n,bidirectional_iterator_tag)
__advance	allocator/iterator.hpp	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator & i,Distance n,input_iterator_tag)
__advance	allocator/iterator.hpp	/^inline void __advance(RandomAccessIterator& i, Distance n, random_access_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator & i,Distance n,random_access_iterator_tag)
__anon22e991b60103	allocator/alloc.hpp	/^enum { __ALIGN = 8 };$/;"	g	namespace:ich
__anon22e991b60203	allocator/alloc.hpp	/^enum { __MAX_BYTES = 128 };$/;"	g	namespace:ich
__anon22e991b60303	allocator/alloc.hpp	/^enum { __NFREELISTS = __MAX_BYTES \/ __ALIGN };$/;"	g	namespace:ich
__copy	contains/rb_tree.hpp	/^    link_type __copy(link_type x, link_type p);$/;"	p	class:ich::rb_tree	typeref:typename:link_type	access:private	signature:(link_type x,link_type p)
__default_alloc_template	allocator/alloc.hpp	/^class __default_alloc_template$/;"	c	namespace:ich
__deque_buf_size	confusing_syntax/some_confusing_syntax.cpp	/^inline size_t __deque_buf_size(size_t n, size_t sz)$/;"	f	typeref:typename:size_t	signature:(size_t n,size_t sz)
__deque_buf_size	contains/deque.hpp	/^inline size_t __deque_buf_size(size_t n, size_t sz) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(size_t n,size_t sz)
__deque_iterator	confusing_syntax/some_confusing_syntax.cpp	/^struct __deque_iterator {$/;"	s	file:
__deque_iterator	contains/deque.hpp	/^struct __deque_iterator {$/;"	s	namespace:ich
__deque_iterator::buffer_size	confusing_syntax/some_confusing_syntax.cpp	/^    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator	typeref:typename:size_t	file:	access:public	signature:()
__deque_iterator::const_iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator	typeref:typename:__deque_iterator<T,const T &,const T *,BufSiz>	file:	access:public
__deque_iterator::iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	struct:__deque_iterator	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	file:	access:public
__destroy	allocator/constructor.hpp	/^inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,T *)
__destroy_aux	allocator/constructor.hpp	/^inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,__false_type)
__destroy_aux	allocator/constructor.hpp	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator,ForwardIterator,__true_type)
__distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type __distance(InputIterator first, /;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last,input_iterator_tag)
__distance	allocator/iterator.hpp	/^inline typename iterator_traits<RandomAccessIterator>::difference_type __distance(RandomAccessIt/;"	f	namespace:ich	typeref:typename:iterator_traits<RandomAccessIterator>::difference_type	signature:(RandomAccessIterator first,RandomAccessIterator last,random_access_iterator_tag)
__distance	allocator/iterator.hpp	/^inline void __distance(InputIterator first, InputIterator last, Distance &n, input_iterator_tag)/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator first,InputIterator last,Distance & n,input_iterator_tag)
__distance	allocator/iterator.hpp	/^inline void __distance(RandomAccessIterator first, RandomAccessIterator last, Distance &n, rando/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance & n,random_access_iterator_tag tag)
__erase	contains/rb_tree.hpp	/^    void __erase(link_type x) {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:private	signature:(link_type x)
__false_type	allocator/__type_traits.hpp	/^struct __false_type { };$/;"	s	namespace:ich
__hashtable_const_iterator	contains/hashtable.hpp	/^    __hashtable_const_iterator() {}$/;"	f	struct:ich::__hashtable_const_iterator	access:public	signature:()
__hashtable_const_iterator	contains/hashtable.hpp	/^    __hashtable_const_iterator(node *n, hashtable *tab) : cur(n), ht(tab) {}$/;"	f	struct:ich::__hashtable_const_iterator	access:public	signature:(node * n,hashtable * tab)
__hashtable_const_iterator	contains/hashtable.hpp	/^struct __hashtable_const_iterator$/;"	s	namespace:ich
__hashtable_iterator	contains/hashtable.hpp	/^    __hashtable_iterator() {}$/;"	f	struct:ich::__hashtable_iterator	access:public	signature:()
__hashtable_iterator	contains/hashtable.hpp	/^    __hashtable_iterator(node *n, hashtable *tab) : cur(n), ht(tab) {}$/;"	f	struct:ich::__hashtable_iterator	access:public	signature:(node * n,hashtable * tab)
__hashtable_iterator	contains/hashtable.hpp	/^struct __hashtable_iterator$/;"	s	namespace:ich
__hashtable_node	contains/hashtable.hpp	/^struct __hashtable_node$/;"	s	namespace:ich
__insert	contains/rb_tree.hpp	/^    iterator __insert(base_ptr x, base_ptr y, const value_type &v);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:private	signature:(base_ptr x,base_ptr y,const value_type & v)
__insert	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__insert(base_ptr x_, base_ptr y_, const Value /;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(base_ptr x_,base_ptr y_,const Value & v)
__list_iterator	contains/list.hpp	/^    __list_iterator() {}$/;"	f	struct:ich::__list_iterator	access:public	signature:()
__list_iterator	contains/list.hpp	/^    __list_iterator(const iterator &x) : node(x.node) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(const iterator & x)
__list_iterator	contains/list.hpp	/^    __list_iterator(link_type x) : node(x) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(link_type x)
__list_iterator	contains/list.hpp	/^struct __list_iterator {$/;"	s	namespace:ich
__list_iterator	contains/list_temp.hpp	/^    __list_iterator() {}$/;"	f	struct:ich::__list_iterator	access:public	signature:()
__list_iterator	contains/list_temp.hpp	/^    __list_iterator(const iterator &x) : node(x.node) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(const iterator & x)
__list_iterator	contains/list_temp.hpp	/^    __list_iterator(link_type x) : node(x) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(link_type x)
__list_iterator	contains/list_temp.hpp	/^struct __list_iterator {$/;"	s	namespace:ich
__list_node	contains/list.hpp	/^struct __list_node {$/;"	s	namespace:ich
__list_node	contains/list_temp.hpp	/^struct __list_node {$/;"	s	namespace:ich
__lower_bound	contains/algorithm.hpp	/^ForwardIterator __lower_bound (ForwardIterator first, ForwardIterator last, const T& value, Comp/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Compare comp,Distance *,forward_iterator_tag)
__lower_bound	contains/algorithm.hpp	/^ForwardIterator __lower_bound (ForwardIterator first, ForwardIterator last, const T& value, Dist/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Distance *,forward_iterator_tag)
__lower_bound	contains/algorithm.hpp	/^RandomAccessIterator __lower_bound (RandomAccessIterator first, RandomAccessIterator last, const/;"	f	namespace:ich	typeref:typename:RandomAccessIterator	signature:(RandomAccessIterator first,RandomAccessIterator last,const T & value,Compare comp,Distance *,random_access_iterator_tag)
__lower_bound	contains/algorithm.hpp	/^RandomAccessIterator __lower_bound (RandomAccessIterator first, RandomAccessIterator last, const/;"	f	namespace:ich	typeref:typename:RandomAccessIterator	signature:(RandomAccessIterator first,RandomAccessIterator last,const T & value,Distance *,random_access_iterator_tag)
__make_heap	contains/algorithm.hpp	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T *, Distance *) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Distance *)
__make_heap	contains/algorithm.hpp	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T *, Distance *, Compare/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Distance *,Compare comp)
__malloc_alloc_oom_handler	allocator/alloc.hpp	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:ich::__malloc_alloc_template	typeref:typename:void (*)()	access:private
__malloc_alloc_template	allocator/alloc.hpp	/^class __malloc_alloc_template$/;"	c	namespace:ich
__malloc_alloc_template	allocator/alloc.hpp	/^void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;$/;"	v	namespace:ich	typeref:typename:void (* <inst>::__malloc_alloc_oom_handler)()
__pop_heap	contains/algorithm.hpp	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterat/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,RandomAccessIterator result,T value,Distance *)
__pop_heap	contains/algorithm.hpp	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterat/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,RandomAccessIterator result,T value,Distance *,Compare comp)
__pop_heap_aux	contains/algorithm.hpp	/^inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *)
__pop_heap_aux	contains/algorithm.hpp	/^inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*, Compare co/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Compare comp)
__push_heap	contains/algorithm.hpp	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance topIndex,T value)
__push_heap	contains/algorithm.hpp	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value, Com/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance topIndex,T value,Compare comp)
__push_heap_aux	contains/algorithm.hpp	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance *, T/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance *,T *)
__push_heap_aux	contains/algorithm.hpp	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance *, T/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance *,T *,Compare comp)
__rb_tree_base_iterator	contains/rb_tree.hpp	/^struct __rb_tree_base_iterator$/;"	s	namespace:ich
__rb_tree_black	contains/rb_tree.hpp	/^const __rb_tree_color_type __rb_tree_black  = true; \/\/ 黑色为1$/;"	v	namespace:ich	typeref:typename:const __rb_tree_color_type
__rb_tree_color_type	contains/rb_tree.hpp	/^typedef bool __rb_tree_color_type;$/;"	t	namespace:ich	typeref:typename:bool
__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator() {}$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:()
__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator(const iterator &it) { node = it.node; }$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:(const iterator & it)
__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:(link_type x)
__rb_tree_iterator	contains/rb_tree.hpp	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s	namespace:ich	inherits:__rb_tree_base_iterator
__rb_tree_node	contains/rb_tree.hpp	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s	namespace:ich	inherits:__rb_tree_node_base
__rb_tree_node_base	contains/rb_tree.hpp	/^struct __rb_tree_node_base$/;"	s	namespace:ich
__rb_tree_rebalance	contains/rb_tree.hpp	/^inline void __rb_tree_rebalance(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
__rb_tree_rebalance_for_erase	contains/rb_tree.hpp	/^    __rb_tree_node_base* __rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	p	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	access:private	signature:(__rb_tree_node_base * z,__rb_tree_node_base * & root,__rb_tree_node_base * & leftmost,__rb_tree_node_base * & rightmost)
__rb_tree_rebalance_for_erase	contains/rb_tree.hpp	/^__rb_tree_node_base* rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_tree_rebalance_for_er/;"	f	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	signature:(__rb_tree_node_base * z,__rb_tree_node_base * & root,__rb_tree_node_base * & leftmost,__rb_tree_node_base * & rightmost)
__rb_tree_red	contains/rb_tree.hpp	/^const __rb_tree_color_type __rb_tree_red    = false;\/\/ 红色为0$/;"	v	namespace:ich	typeref:typename:const __rb_tree_color_type
__rb_tree_rotate_left	contains/rb_tree.hpp	/^inline void __rb_tree_rotate_left(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
__rb_tree_rotate_right	contains/rb_tree.hpp	/^inline void __rb_tree_rotate_right(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
__slist_iterator	contains/slist.hpp	/^    __slist_iterator(): __slist_iterator_base(0) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:()
__slist_iterator	contains/slist.hpp	/^    __slist_iterator(const iterator &x) : __slist_iterator_base(x.node) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:(const iterator & x)
__slist_iterator	contains/slist.hpp	/^    __slist_iterator(list_node *x) : __slist_iterator_base(x) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:(list_node * x)
__slist_iterator	contains/slist.hpp	/^struct __slist_iterator : public __slist_iterator_base$/;"	s	namespace:ich	inherits:__slist_iterator_base
__slist_iterator_base	contains/slist.hpp	/^    __slist_iterator_base(__slist_node_base *x) : node(x) {}$/;"	f	struct:ich::__slist_iterator_base	access:public	signature:(__slist_node_base * x)
__slist_iterator_base	contains/slist.hpp	/^struct __slist_iterator_base$/;"	s	namespace:ich
__slist_make_link	contains/slist.hpp	/^inline __slist_node_base* __slist_make_link(__slist_node_base *prev_node, __slist_node_base *new/;"	f	namespace:ich	typeref:typename:__slist_node_base *	signature:(__slist_node_base * prev_node,__slist_node_base * new_node)
__slist_node	contains/slist.hpp	/^struct __slist_node : public __slist_node_base$/;"	s	namespace:ich	inherits:__slist_node_base
__slist_node_base	contains/slist.hpp	/^struct __slist_node_base$/;"	s	namespace:ich
__slist_size	contains/slist.hpp	/^inline size_t __slist_size(__slist_node_base *node) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(__slist_node_base * node)
__stl_hash_string	contains/hash_fun.hpp	/^inline size_t __stl_hash_string(const char *s) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(const char * s)
__stl_next_prime	contains/hashtable.hpp	/^inline unsigned long __stl_next_prime(unsigned long n) {$/;"	f	namespace:ich	typeref:typename:unsigned long	signature:(unsigned long n)
__stl_num_primes	contains/hashtable.hpp	/^static const int __stl_num_primes = 28;$/;"	v	namespace:ich	typeref:typename:const int
__stl_prime_list	contains/hashtable.hpp	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v	namespace:ich	typeref:typename:const unsigned long[]
__true_type	allocator/__type_traits.hpp	/^struct __true_type { };$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^struct __type_traits<signed char> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<bool> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<char> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const signed char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const unsigned char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<double> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<float> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<int> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long double> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long long> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<short> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<signed char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned char*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned char> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned int> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned long long> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned long> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned short> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<wchar_t> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <class T> struct __type_traits<T*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <class T> struct __type_traits<const T*> {$/;"	s	namespace:ich
__type_traits	allocator/__type_traits.hpp	/^template <class type> struct __type_traits {$/;"	s	namespace:ich
__uninitialized_copy	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy(InputIterator first, InputIterator last, ForwardIter/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,T *)
__uninitialized_copy_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, Forward/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,__false_type)
__uninitialized_copy_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, Forward/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,__true_type)
__uninitialized_fill	allocator/uninitialized.hpp	/^inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &x, T1 *) /;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,T1 *)
__uninitialized_fill_aux	allocator/uninitialized.hpp	/^inline void __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T &x, __/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,__false_type)
__uninitialized_fill_aux	allocator/uninitialized.hpp	/^inline void __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T &x, __/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,__true_type)
__uninitialized_fill_n	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, const T &x, T1 *) {$/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,T1 *)
__uninitialized_fill_n_aux	allocator/uninitialized.hpp	/^ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, const T &x, __false_ty/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,__false_type)
__uninitialized_fill_n_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, const T &x, __t/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,__true_type)
_allocate	allocator/jj_allocator.hpp	/^inline T* _allocate(std::ptrdiff_t size, T*)$/;"	f	namespace:JJ	typeref:typename:T *	signature:(std::ptrdiff_t size,T *)
_construct	allocator/jj_allocator.hpp	/^inline void _construct(T1 *p, const T2 &value)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T1 * p,const T2 & value)
_data	confusing_syntax/some_confusing_syntax.cpp	/^    static int _data;$/;"	m	class:vector	typeref:typename:int	file:	access:public
_data	confusing_syntax/some_confusing_syntax.cpp	/^template<> int vector<char>::_data = 2;$/;"	m	class:vector<char>	typeref:typename:int
_data	confusing_syntax/some_confusing_syntax.cpp	/^template<> int vector<int>::_data = 1;$/;"	m	class:vector<int>	typeref:typename:int
_deallocate	allocator/jj_allocator.hpp	/^inline void _deallocate(T *buffer)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T * buffer)
_destroy	allocator/jj_allocator.hpp	/^inline void _destroy(T *ptr)$/;"	f	namespace:JJ	typeref:typename:void	signature:(T * ptr)
address	allocator/jj_allocator.hpp	/^    pointer address(reference x)$/;"	f	class:JJ::allocator	typeref:typename:pointer	access:public	signature:(reference x)
address	allocator/std_allocator.hpp	/^    pointer address(reference x) { retunr (poitner)&x; }$/;"	f	class:allocator	typeref:typename:pointer	access:public	signature:(reference x)
advance	allocator/iterator.hpp	/^inline void advance(InputIterator& i, Distance n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator & i,Distance n)
alloc	allocator/alloc.hpp	/^#define alloc /;"	d
alloc	confusing_syntax/some_confusing_syntax.cpp	/^class alloc {};$/;"	c	file:
allocate	allocator/alloc.hpp	/^    static void* allocate(size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void *	access:public	signature:(size_t n)
allocate	allocator/alloc.hpp	/^    static void* allocate(size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	access:public	signature:(size_t n)
allocate	allocator/allocator.hpp	/^    static T* allocate() {$/;"	f	class:ich::allocator	typeref:typename:T *	access:public	signature:()
allocate	allocator/allocator.hpp	/^    static T* allocate(size_t n) {$/;"	f	class:ich::allocator	typeref:typename:T *	access:public	signature:(size_t n)
allocate	allocator/jj_allocator.hpp	/^    pointer allocate(size_type n, const void *hint = 0)$/;"	f	class:JJ::allocator	typeref:typename:pointer	access:public	signature:(size_type n,const void * hint=0)
allocate	allocator/std_allocator.hpp	/^    pointer allocate(size_type n) {$/;"	f	class:allocator	typeref:typename:pointer	access:public	signature:(size_type n)
allocate	allocator/std_allocator.hpp	/^inline T* allocate(ptrdiff_t size, T*) {$/;"	f	typeref:typename:T *	signature:(ptrdiff_t size,T *)
allocate_and_copy	contains/vector.hpp	/^    iterator allocate_and_copy(size_type n, iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(size_type n,iterator first,iterator last)
allocate_and_fill	contains/vector.hpp	/^    iterator allocate_and_fill(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(iterator first,iterator last)
allocate_and_fill	contains/vector.hpp	/^    iterator allocate_and_fill(size_type n, const T &x) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(size_type n,const T & x)
allocate_node	contains/deque.hpp	/^    pointer allocate_node() { return data_allocator::allocate(sizeof(pointer)); }$/;"	f	class:ich::deque	typeref:typename:pointer	access:protected	signature:()
allocator	allocator/allocator.hpp	/^class allocator$/;"	c	namespace:ich
allocator	allocator/jj_allocator.hpp	/^class allocator$/;"	c	namespace:JJ
allocator	allocator/std_allocator.hpp	/^class allocator {$/;"	c
allocator	allocator/std_allocator.hpp	/^class allocator<void> {$/;"	c
allocator::address	allocator/std_allocator.hpp	/^    pointer address(reference x) { retunr (poitner)&x; }$/;"	f	class:allocator	typeref:typename:pointer	access:public	signature:(reference x)
allocator::allocate	allocator/std_allocator.hpp	/^    pointer allocate(size_type n) {$/;"	f	class:allocator	typeref:typename:pointer	access:public	signature:(size_type n)
allocator::const_address	allocator/std_allocator.hpp	/^    const_pointer const_address(const reference x) { return (const_pointer)&x; }$/;"	f	class:allocator	typeref:typename:const_pointer	access:public	signature:(const reference x)
allocator::const_pointer	allocator/std_allocator.hpp	/^    typedef const T* const_pointer;$/;"	t	class:allocator	typeref:typename:const T *	access:public
allocator::const_referece	allocator/std_allocator.hpp	/^    typedef const T& const_referece;$/;"	t	class:allocator	typeref:typename:const T &	access:public
allocator::deallocate	allocator/std_allocator.hpp	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator	typeref:typename:void	access:public	signature:(pointer p)
allocator::difference_type	allocator/std_allocator.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator	typeref:typename:ptrdiff_t	access:public
allocator::init_page_size	allocator/std_allocator.hpp	/^    size_type init_page_size() {$/;"	f	class:allocator	typeref:typename:size_type	access:public	signature:()
allocator::max_size	allocator/std_allocator.hpp	/^    size_type max_size() {$/;"	f	class:allocator	typeref:typename:size_type	access:public	signature:()
allocator::pointer	allocator/std_allocator.hpp	/^    typedef T* pointer;$/;"	t	class:allocator	typeref:typename:T *	access:public
allocator::pointer	allocator/std_allocator.hpp	/^    typedef void *pointer;$/;"	t	class:allocator	typeref:typename:void *	access:public
allocator::reference	allocator/std_allocator.hpp	/^    typedef T& reference;$/;"	t	class:allocator	typeref:typename:T &	access:public
allocator::size_tyep	allocator/std_allocator.hpp	/^    typedef size_t size_tyep;$/;"	t	class:allocator	typeref:typename:size_t	access:public
allocator::type_value	allocator/std_allocator.hpp	/^    typedef T type_value;$/;"	t	class:allocator	typeref:typename:T	access:public
back	contains/deque.hpp	/^    reference back() {$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:()
back	contains/list_temp.hpp	/^    reference back() { return *(--end()); }$/;"	f	class:ich::list	typeref:typename:reference	access:public	signature:()
back	contains/queue.hpp	/^    reference back() { return c.back(); }$/;"	f	class:ich::queue	typeref:typename:reference	access:public	signature:()
back	contains/vector.hpp	/^    reference back() { return *(end() - 1); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:()
base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base*    base_ptr;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	access:protected
base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:ich::__rb_tree_node_base	typeref:typename:__rb_tree_node_base *	access:public
base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base::base_ptr   base_ptr;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:__rb_tree_node_base::base_ptr	access:public
begin	contains/deque.hpp	/^    iterator begin() { return start; }$/;"	f	class:ich::deque	typeref:typename:iterator	access:public	signature:()
begin	contains/hashtable.hpp	/^    iterator begin() {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:()
begin	contains/list_temp.hpp	/^    iterator begin() { return (link_type)((*node).next); }$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:()
begin	contains/map.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:()
begin	contains/multimap.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:()
begin	contains/multiset.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:()
begin	contains/rb_tree.hpp	/^    iterator begin() { return leftmost(); }$/;"	f	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:()
begin	contains/set.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:()
begin	contains/slist.hpp	/^    iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:()
begin	contains/vector.hpp	/^    iterator begin() { return start; }$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:()
bidirectional_iterator_tag	allocator/iterator.hpp	/^struct bidirectional_iterator_tag : public forward_iterator_tag {};$/;"	s	namespace:ich	inherits:forward_iterator_tag
bkt_num	contains/hashtable.hpp	/^    size_type bkt_num(const value_type &obj) { return bkt_num_key(get_key(obj)); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const value_type & obj)
bkt_num	contains/hashtable.hpp	/^    size_type bkt_num(const value_type &obj, size_t n) { return bkt_num_key(get_key(obj), n); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const value_type & obj,size_t n)
bkt_num_key	contains/hashtable.hpp	/^    size_type bkt_num_key(const key_type &key) { return bkt_num_key(key, buckets.size()); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key)
bkt_num_key	contains/hashtable.hpp	/^    size_type bkt_num_key(const key_type &key, size_t n) { return ich::hash<key_type>()(key) % n/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key,size_t n)
bucket_count	contains/hashtable.hpp	/^    size_type bucket_count() const { return buckets.size(); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
buckets	contains/hashtable.hpp	/^    ich::vector<node*, Alloc>       buckets;$/;"	m	class:ich::hashtable	typeref:typename:ich::vector<node *,Alloc>	access:private
buffer_size	confusing_syntax/some_confusing_syntax.cpp	/^    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator	typeref:typename:size_t	file:	access:public	signature:()
buffer_size	contains/deque.hpp	/^    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:size_t	access:public	signature:()
c	confusing_syntax/some_confusing_syntax.cpp	/^    Sequence c;$/;"	m	class:stack	typeref:typename:Sequence	file:	access:private
c	contains/queue.hpp	/^    Sequence c;$/;"	m	class:ich::queue	typeref:typename:Sequence	access:protected
c	contains/stack.hpp	/^    Sequence c;$/;"	m	class:ich::stack	typeref:typename:Sequence	access:protected
call	confusing_syntax/function_ret.cpp	/^int call(int s)$/;"	f	typeref:typename:int	signature:(int s)
capacity	contains/vector.hpp	/^    size_type capacity() const { return size_type(end_of_storage - cbegin()); }$/;"	f	class:ich::vector	typeref:typename:size_type	access:public	signature:() const
category	allocator/iterator.hpp	/^    typedef typename iterator_traits<InputIterator>::iterator_category category;$/;"	t	function:ich::advance	typeref:typename:iterator_traits<InputIterator>::iterator_category
category	allocator/iterator.hpp	/^    typedef typename iterator_traits<InputIterator>::iterator_category category;$/;"	t	function:ich::distance	typeref:typename:iterator_traits<InputIterator>::iterator_category
category	allocator/iterator.hpp	/^    typedef typename iterator_traits<Iterator>::iterator_category category;$/;"	t	function:ich::iterator_category	typeref:typename:iterator_traits<Iterator>::iterator_category
cback	contains/deque.hpp	/^    const_reference cback() const {$/;"	f	class:ich::deque	typeref:typename:const_reference	access:public	signature:() const
cback	contains/queue.hpp	/^    const_reference cback() const { return c.cback(); }$/;"	f	class:ich::queue	typeref:typename:const_reference	access:public	signature:() const
cbegin	contains/hashtable.hpp	/^    const_iterator cbegin() const {$/;"	f	class:ich::hashtable	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/map.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/multimap.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/multiset.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::multiset	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/rb_tree.hpp	/^    const_iterator cbegin() const { return leftmost(); }$/;"	f	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/set.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::set	typeref:typename:const_iterator	access:public	signature:() const
cbegin	contains/vector.hpp	/^    const_iterator cbegin() const { return start; }$/;"	f	class:ich::vector	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/hashtable.hpp	/^    const_iterator cend() { return iterator(0, this); }$/;"	f	class:ich::hashtable	typeref:typename:const_iterator	access:public	signature:()
cend	contains/map.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/multimap.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/multiset.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::multiset	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/rb_tree.hpp	/^    const_iterator cend() const { return header; }$/;"	f	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/set.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::set	typeref:typename:const_iterator	access:public	signature:() const
cend	contains/vector.hpp	/^    const_iterator cend() const { return finish; }$/;"	f	class:ich::vector	typeref:typename:const_iterator	access:public	signature:() const
cfront	contains/deque.hpp	/^    const_reference cfront() const { return *start; }$/;"	f	class:ich::deque	typeref:typename:const_reference	access:public	signature:() const
cfront	contains/queue.hpp	/^    const_reference cfront() const { return c.cfront(); }$/;"	f	class:ich::queue	typeref:typename:const_reference	access:public	signature:() const
chunk_alloc	allocator/alloc.hpp	/^    static char* chunk_alloc(size_t size, int &nobjs);$/;"	p	class:ich::__default_alloc_template	typeref:typename:char *	access:private	signature:(size_t size,int & nobjs)
chunk_alloc	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::chunk_alloc(size_t size, int &nobjs) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:char *	signature:(size_t size,int & nobjs)
clear	contains/deque.hpp	/^    void clear();$/;"	p	class:ich::deque	typeref:typename:void	access:public	signature:()
clear	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
clear	contains/hashtable.hpp	/^    void clear();$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:()
clear	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::clear() {$/;"	f	class:ich::hashtable	typeref:typename:void	signature:()
clear	contains/list_temp.hpp	/^    void clear() {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
clear	contains/map.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:()
clear	contains/multimap.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:()
clear	contains/multiset.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:()
clear	contains/rb_tree.hpp	/^    void clear() {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:public	signature:()
clear	contains/set.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:()
clear	contains/slist.hpp	/^    void clear() {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:()
clear	contains/vector.hpp	/^    void clear() { erase(begin(), end()); }$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:()
client_data	allocator/alloc.hpp	/^        char client_data[1];    \/\/ 对客户可见的$/;"	m	union:ich::__default_alloc_template::obj	typeref:typename:char[1]	access:public
clone	contains/rb_tree.hpp	/^    link_type clone(link_type x) {$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
color	contains/rb_tree.hpp	/^    color_type  color;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:color_type	access:public
color	contains/rb_tree.hpp	/^    static color_type& color(base_ptr x) { return (color_type&)(x->color); }$/;"	f	class:ich::rb_tree	typeref:typename:color_type &	access:protected	signature:(base_ptr x)
color	contains/rb_tree.hpp	/^    static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:ich::rb_tree	typeref:typename:color_type &	access:protected	signature:(link_type x)
color_type	contains/rb_tree.hpp	/^    typedef __rb_tree_color_type    color_type;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_color_type	access:protected
color_type	contains/rb_tree.hpp	/^    typedef __rb_tree_color_type color_type;$/;"	t	struct:ich::__rb_tree_node_base	typeref:typename:__rb_tree_color_type	access:public
comp	contains/map.hpp	/^        Compare comp;$/;"	m	class:ich::map::value_compare	typeref:typename:Compare	access:protected
comp	contains/multimap.hpp	/^        Compare comp;$/;"	m	class:ich::multimap::value_compare	typeref:typename:Compare	access:protected
const_address	allocator/jj_allocator.hpp	/^    const_pointer const_address(const_reference x)$/;"	f	class:JJ::allocator	typeref:typename:const_pointer	access:public	signature:(const_reference x)
const_address	allocator/std_allocator.hpp	/^    const_pointer const_address(const reference x) { return (const_pointer)&x; }$/;"	f	class:allocator	typeref:typename:const_pointer	access:public	signature:(const reference x)
const_iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator	typeref:typename:__deque_iterator<T,const T &,const T *,BufSiz>	file:	access:public
const_iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,const T &,const T *,BufSiz>	access:public
const_iterator	contains/deque.hpp	/^    typedef __deque_iterator<const T, const T&, const T*, BufSiz> const_iterator;$/;"	t	class:ich::deque	typeref:typename:__deque_iterator<const T,const T &,const T *,BufSiz>	access:public
const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>    cons/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>    cons/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc> const_i/;"	t	class:ich::hashtable	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
const_iterator	contains/list_temp.hpp	/^    typedef __list_iterator<const T> const_iterator;$/;"	t	class:ich::list	typeref:typename:__list_iterator<const T>	access:public
const_iterator	contains/map.hpp	/^    typedef typename rep_type::const_iterator           const_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::const_iterator	access:public
const_iterator	contains/multimap.hpp	/^    typedef typename rep_type::const_iterator           const_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_iterator	access:public
const_iterator	contains/multiset.hpp	/^    typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_iterator	access:public
const_iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, const Value&, const Value*>   const_iterator;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,const Value &,const Value * >	access:public
const_iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<value_type, const_reference, const_pointer> const_iterator;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_iterator<value_type,const_reference,const_pointer>	access:public
const_iterator	contains/set.hpp	/^    typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:ich::set	typeref:typename:rep_type::const_iterator	access:public
const_iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator<T,const T &,const T * >	access:public
const_iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,const T &,const T * >	access:public
const_iterator	contains/vector.hpp	/^    typedef const value_type* const_iterator;$/;"	t	class:ich::vector	typeref:typename:const value_type *	access:public
const_pointer	allocator/allocator.hpp	/^    typedef const T*        const_pointer;$/;"	t	class:ich::allocator	typeref:typename:const T *	access:public
const_pointer	allocator/jj_allocator.hpp	/^    typedef const T*        const_pointer;$/;"	t	class:JJ::allocator	typeref:typename:const T *	access:public
const_pointer	allocator/std_allocator.hpp	/^    typedef const T* const_pointer;$/;"	t	class:allocator	typeref:typename:const T *	access:public
const_pointer	contains/hashtable.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:ich::hashtable	typeref:typename:const value_type *	access:public
const_pointer	contains/map.hpp	/^    typedef typename rep_type::const_pointer            const_pointer;$/;"	t	class:ich::map	typeref:typename:rep_type::const_pointer	access:public
const_pointer	contains/multimap.hpp	/^    typedef typename rep_type::const_pointer            const_pointer;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_pointer	access:public
const_pointer	contains/multiset.hpp	/^    typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_pointer	access:public
const_pointer	contains/rb_tree.hpp	/^    typedef const value_type*   const_pointer;$/;"	t	class:ich::rb_tree	typeref:typename:const value_type *	access:public
const_pointer	contains/set.hpp	/^    typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:ich::set	typeref:typename:rep_type::const_pointer	access:public
const_pointer	contains/slist.hpp	/^    typedef const value_type*   const_pointer;$/;"	t	class:ich::slist	typeref:typename:const value_type *	access:public
const_referece	allocator/std_allocator.hpp	/^    typedef const T& const_referece;$/;"	t	class:allocator	typeref:typename:const T &	access:public
const_reference	allocator/allocator.hpp	/^    typedef const T&        const_reference;$/;"	t	class:ich::allocator	typeref:typename:const T &	access:public
const_reference	allocator/jj_allocator.hpp	/^    typedef const T&        const_reference;$/;"	t	class:JJ::allocator	typeref:typename:const T &	access:public
const_reference	contains/deque.hpp	/^    typedef const T&    const_reference;$/;"	t	class:ich::deque	typeref:typename:const T &	access:public
const_reference	contains/hashtable.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:ich::hashtable	typeref:typename:const value_type &	access:public
const_reference	contains/map.hpp	/^    typedef typename rep_type::const_reference          const_reference;$/;"	t	class:ich::map	typeref:typename:rep_type::const_reference	access:public
const_reference	contains/multimap.hpp	/^    typedef typename rep_type::const_reference          const_reference;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_reference	access:public
const_reference	contains/multiset.hpp	/^    typedef typename rep_type::const_reference const_reference;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_reference	access:public
const_reference	contains/queue.hpp	/^    typedef typename Sequence::const_reference  const_reference;$/;"	t	class:ich::queue	typeref:typename:Sequence::const_reference	access:public
const_reference	contains/rb_tree.hpp	/^    typedef const value_type&   const_reference;$/;"	t	class:ich::rb_tree	typeref:typename:const value_type &	access:public
const_reference	contains/set.hpp	/^    typedef typename rep_type::const_reference const_reference;$/;"	t	class:ich::set	typeref:typename:rep_type::const_reference	access:public
const_reference	contains/slist.hpp	/^    typedef const value_type&   const_reference;$/;"	t	class:ich::slist	typeref:typename:const value_type &	access:public
const_reference	contains/stack.hpp	/^    typedef typename Sequence::const_reference  const_reference;$/;"	t	class:ich::stack	typeref:typename:Sequence::const_reference	access:public
const_reference	contains/vector.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:ich::vector	typeref:typename:const value_type &	access:public
const_reverse_iterator	contains/map.hpp	/^    typedef typename rep_type::const_reverse_iterator   const_reverse_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::const_reverse_iterator	access:public
const_reverse_iterator	contains/multimap.hpp	/^    typedef typename rep_type::const_reverse_iterator   const_reverse_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_reverse_iterator	access:public
construct	allocator/constructor.hpp	/^inline void construct(T1 *p, const T2 &value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T1 * p,const T2 & value)
construct	allocator/jj_allocator.hpp	/^    void construct(pointer p, const T &value)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p,const T & value)
copy	allocator/uninitialized.hpp	/^inline void copy(T *source, T *destination, int n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n)
copy	allocator/uninitialized.hpp	/^void copy(T *source, T *destination, int n, __false_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n,__false_type)
copy	allocator/uninitialized.hpp	/^void copy(T *source, T *destination, int n, __true_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n,__true_type)
copy_backward	contains/algorithm.hpp	/^BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last) {$/;"	f	namespace:ich	typeref:typename:BidirIt2	signature:(BidirIt1 first,BidirIt1 last,BidirIt2 d_last)
copy_from	contains/hashtable.hpp	/^    void copy_from(const hashtable &ht);$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:(const hashtable & ht)
copy_from	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::copy_from(const hashtable &ht)/;"	f	class:ich::hashtable	typeref:typename:void	signature:(const hashtable & ht)
count	contains/hashtable.hpp	/^    size_type count(const key_type &key) const {$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key) const
count	contains/map.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:(const key_type & x) const
count	contains/multimap.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:(const key_type & x) const
count	contains/multiset.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:(const key_type & x) const
count	contains/rb_tree.hpp	/^    size_type count(const key_type &x) const;$/;"	p	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:(const key_type & x) const
count	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::size_type	signature:(const Key & k) const
count	contains/set.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:(const key_type & x) const
create_map_and_nodes	contains/deque.hpp	/^    void create_map_and_nodes(size_type num_elements);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type num_elements)
create_map_and_nodes	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type num_elements)
create_node	contains/list_temp.hpp	/^    link_type create_node(const T &x) {$/;"	f	class:ich::list	typeref:typename:link_type	access:protected	signature:(const T & x)
create_node	contains/rb_tree.hpp	/^    link_type create_node(const value_type &x) {$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(const value_type & x)
create_node	contains/slist.hpp	/^    static list_node* create_node(const value_type &x) {$/;"	f	class:ich::slist	typeref:typename:list_node *	access:private	signature:(const value_type & x)
ctop	contains/stack.hpp	/^    const_reference ctop() const { return c.cback(); }$/;"	f	class:ich::stack	typeref:typename:const_reference	access:public	signature:() const
cur	contains/deque.hpp	/^    T *cur;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
cur	contains/hashtable.hpp	/^    const node *cur;$/;"	m	struct:ich::__hashtable_const_iterator	typeref:typename:const node *	access:public
cur	contains/hashtable.hpp	/^    node *cur;$/;"	m	struct:ich::__hashtable_iterator	typeref:typename:node *	access:public
data	contains/list.hpp	/^    T data;$/;"	m	struct:ich::__list_node	typeref:typename:T	access:public
data	contains/list_temp.hpp	/^    T data;$/;"	m	struct:ich::__list_node	typeref:typename:T	access:public
data	contains/slist.hpp	/^    T data;$/;"	m	struct:ich::__slist_node	typeref:typename:T	access:public
data_allocator	contains/deque.hpp	/^    typedef allocator<value_type>   data_allocator;$/;"	t	class:ich::deque	typeref:typename:allocator<value_type>	access:protected
data_allocator	contains/vector.hpp	/^    typedef Alloc data_allocator;$/;"	t	class:ich::vector	typeref:typename:Alloc	access:protected
data_type	contains/map.hpp	/^    typedef T                       data_type;$/;"	t	class:ich::map	typeref:typename:T	access:public
data_type	contains/multimap.hpp	/^    typedef T                       data_type;$/;"	t	class:ich::multimap	typeref:typename:T	access:public
deallocate	allocator/alloc.hpp	/^    static void deallocate(void *p, size_t \/* n *\/) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void	access:public	signature:(void * p,size_t)
deallocate	allocator/alloc.hpp	/^    static void deallocate(void *p, size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void	access:public	signature:(void * p,size_t n)
deallocate	allocator/allocator.hpp	/^    static void deallocate(T *ptr) {$/;"	f	class:ich::allocator	typeref:typename:void	access:public	signature:(T * ptr)
deallocate	allocator/allocator.hpp	/^    static void deallocate(T *ptr, size_t n) {$/;"	f	class:ich::allocator	typeref:typename:void	access:public	signature:(T * ptr,size_t n)
deallocate	allocator/jj_allocator.hpp	/^    void deallocate(pointer p, size_type n)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p,size_type n)
deallocate	allocator/std_allocator.hpp	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator	typeref:typename:void	access:public	signature:(pointer p)
deallocate	allocator/std_allocator.hpp	/^inline void deallocate(T *buffer) {$/;"	f	typeref:typename:void	signature:(T * buffer)
deallocate	contains/vector.hpp	/^    void deallocate() { if (start) data_allocator::deallocate(start, end_of_storage - start); }$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:()
deallocate_node	contains/deque.hpp	/^    void deallocate_node(pointer x) { data_allocator::deallocate(x, 1); }$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(pointer x)
decrement	contains/rb_tree.hpp	/^    void decrement() {$/;"	f	struct:ich::__rb_tree_base_iterator	typeref:typename:void	access:public	signature:()
delete_node	contains/hashtable.hpp	/^    void delete_node(node *n) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(node * n)
deque	confusing_syntax/some_confusing_syntax.cpp	/^    deque() { std::cout << "deque" << std::endl; }$/;"	f	class:deque	file:	access:public	signature:()
deque	confusing_syntax/some_confusing_syntax.cpp	/^class deque {$/;"	c	file:
deque	contains/deque.hpp	/^    deque(int n, const value_type &value) : start(), finish(), map(0), map_size(0) { fill_initia/;"	f	class:ich::deque	access:public	signature:(int n,const value_type & value)
deque	contains/deque.hpp	/^class deque {$/;"	c	namespace:ich
deque::deque	confusing_syntax/some_confusing_syntax.cpp	/^    deque() { std::cout << "deque" << std::endl; }$/;"	f	class:deque	file:	access:public	signature:()
deque::iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	class:deque	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	file:	access:public
deque_test	contains/test.cpp	/^void deque_test() {$/;"	f	typeref:typename:void	signature:()
destory	allocator/constructor.hpp	/^inline void destory(char *, char *) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(char *,char *)
destory	allocator/constructor.hpp	/^inline void destory(wchar_t *, wchar_t *) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(wchar_t *,wchar_t *)
destroy	allocator/constructor.hpp	/^inline void destroy(ForwardIterator first, ForwardIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last)
destroy	allocator/constructor.hpp	/^inline void destroy(T *pointer) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * pointer)
destroy	allocator/jj_allocator.hpp	/^    void destroy(pointer p)$/;"	f	class:JJ::allocator	typeref:typename:void	access:public	signature:(pointer p)
destroy_node	contains/list_temp.hpp	/^    void destroy_node(link_type p) {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(link_type p)
destroy_node	contains/rb_tree.hpp	/^    void destroy_node(link_type p) {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:protected	signature:(link_type p)
destroy_node	contains/slist.hpp	/^    static void destroy_node(list_node *node) {$/;"	f	class:ich::slist	typeref:typename:void	access:private	signature:(list_node * node)
difference_type	allocator/allocator.hpp	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:ich::allocator	typeref:typename:std::ptrdiff_t	access:public
difference_type	allocator/iterator.hpp	/^    typedef Distance    difference_type;$/;"	t	struct:ich::iterator	typeref:typename:Distance	access:public
difference_type	allocator/iterator.hpp	/^    typedef ptrdiff_t                   difference_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:ptrdiff_t	access:public
difference_type	allocator/iterator.hpp	/^    typedef typename Iterator::difference_type      difference_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::difference_type	access:public
difference_type	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::difference_type* difference_type(const Iterator&) {$/;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::difference_type *	signature:(const Iterator &)
difference_type	allocator/jj_allocator.hpp	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:JJ::allocator	typeref:typename:std::ptrdiff_t	access:public
difference_type	allocator/std_allocator.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/deque.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/deque.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	class:ich::deque	typeref:typename:ptrdiff_t	access:public
difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t               difference_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t               difference_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:ich::hashtable	typeref:typename:ptrdiff_t	access:public
difference_type	contains/list.hpp	/^    typedef ptrdiff_t       difference_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/list_temp.hpp	/^    typedef ptrdiff_t       difference_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/map.hpp	/^    typedef typename rep_type::difference_type          difference_type;$/;"	t	class:ich::map	typeref:typename:rep_type::difference_type	access:public
difference_type	contains/multimap.hpp	/^    typedef typename rep_type::difference_type          difference_type;$/;"	t	class:ich::multimap	typeref:typename:rep_type::difference_type	access:public
difference_type	contains/multiset.hpp	/^    typedef typename rep_type::difference_type difference_type;$/;"	t	class:ich::multiset	typeref:typename:rep_type::difference_type	access:public
difference_type	contains/rb_tree.hpp	/^    typedef ptrdiff_t                       difference_type;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:ptrdiff_t	access:public
difference_type	contains/rb_tree.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	class:ich::rb_tree	typeref:typename:ptrdiff_t	access:public
difference_type	contains/set.hpp	/^    typedef typename rep_type::difference_type difference_type;$/;"	t	class:ich::set	typeref:typename:rep_type::difference_type	access:public
difference_type	contains/slist.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	class:ich::slist	typeref:typename:ptrdiff_t	access:public
difference_type	contains/slist.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:ptrdiff_t	access:public
difference_type	contains/vector.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	class:ich::vector	typeref:typename:ptrdiff_t	access:public
distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, In/;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last)
distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, In/;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last,input_iterator_tag)
distance	allocator/iterator.hpp	/^inline void distance(InputIterator first, InputIterator last, Distance &n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator first,InputIterator last,Distance & n)
distance_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<ForwardIterator>::difference_type* distance_type;$/;"	t	function:ich::lower_bound	typeref:typename:iterator_traits<ForwardIterator>::difference_type *
distance_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::difference_type* distance_type;$/;"	t	function:ich::__pop_heap_aux	typeref:typename:iterator_traits<RandomAccessIterator>::difference_type *
distance_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::difference_type* distance_type;$/;"	t	function:ich::make_heap	typeref:typename:iterator_traits<RandomAccessIterator>::difference_type *
distance_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::difference_type* distance_type;$/;"	t	function:ich::push_heap	typeref:typename:iterator_traits<RandomAccessIterator>::difference_type *
elems_in_bucket	contains/hashtable.hpp	/^    size_type elems_in_bucket(size_type bucket) const {$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(size_type bucket) const
empty	contains/deque.hpp	/^    bool empty() const { return finish == start; }$/;"	f	class:ich::deque	typeref:typename:bool	access:public	signature:() const
empty	contains/hashtable.hpp	/^    bool empty() const { return size() == 0; }$/;"	f	class:ich::hashtable	typeref:typename:bool	access:public	signature:() const
empty	contains/list_temp.hpp	/^    bool empty() const { return node->next == node; }$/;"	f	class:ich::list	typeref:typename:bool	access:public	signature:() const
empty	contains/map.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::map	typeref:typename:bool	access:public	signature:() const
empty	contains/multimap.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::multimap	typeref:typename:bool	access:public	signature:() const
empty	contains/multiset.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::multiset	typeref:typename:bool	access:public	signature:() const
empty	contains/queue.hpp	/^    bool empty() const { return c.empty(); }$/;"	f	class:ich::queue	typeref:typename:bool	access:public	signature:() const
empty	contains/rb_tree.hpp	/^    bool empty() const { return node_count == 0; }$/;"	f	class:ich::rb_tree	typeref:typename:bool	access:public	signature:() const
empty	contains/set.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::set	typeref:typename:bool	access:public	signature:() const
empty	contains/slist.hpp	/^    bool empty() const { return head.next == 0; }$/;"	f	class:ich::slist	typeref:typename:bool	access:public	signature:() const
empty	contains/stack.hpp	/^    bool empty() const { return c.empty(); }$/;"	f	class:ich::stack	typeref:typename:bool	access:public	signature:() const
empty	contains/vector.hpp	/^    bool empty() const { return cbegin() == cend(); }$/;"	f	class:ich::vector	typeref:typename:bool	access:public	signature:() const
empty_initialize	contains/list_temp.hpp	/^    void empty_initialize() {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:()
end	contains/deque.hpp	/^    iterator end() { return finish; }$/;"	f	class:ich::deque	typeref:typename:iterator	access:public	signature:()
end	contains/hashtable.hpp	/^    iterator end() { return iterator(0, this); }$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:()
end	contains/list_temp.hpp	/^    iterator end() { return node; }$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:()
end	contains/map.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:()
end	contains/multimap.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:()
end	contains/multiset.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:()
end	contains/rb_tree.hpp	/^    iterator end() const { return header; }$/;"	f	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:() const
end	contains/set.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:()
end	contains/slist.hpp	/^    iterator end() { return iterator(0); }$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:()
end	contains/vector.hpp	/^    iterator end() { return finish; }$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:()
end_free	allocator/alloc.hpp	/^    static char *end_free;      \/\/ 内存池结束位置$/;"	m	class:ich::__default_alloc_template	typeref:typename:char *	access:private
end_free	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:char *
end_of_storage	contains/vector.hpp	/^    iterator end_of_storage;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
equal_range	contains/map.hpp	/^    ich::pair<iterator, iterator> equal_range(const key_type &x) { return t.equal_range(x); }$/;"	f	class:ich::map	typeref:typename:ich::pair<iterator,iterator>	access:public	signature:(const key_type & x)
equal_range	contains/map.hpp	/^    ich::pari<const_iterator, const_iterator> equal_range(const key_type &x) const { return t.eq/;"	f	class:ich::map	typeref:typename:ich::pari<const_iterator,const_iterator>	access:public	signature:(const key_type & x) const
equal_range	contains/multimap.hpp	/^    ich::pair<iterator, iterator> equal_range(const key_type &x) { return t.equal_range(x); }$/;"	f	class:ich::multimap	typeref:typename:ich::pair<iterator,iterator>	access:public	signature:(const key_type & x)
equal_range	contains/multimap.hpp	/^    ich::pari<const_iterator, const_iterator> equal_range(const key_type &x) const { return t.eq/;"	f	class:ich::multimap	typeref:typename:ich::pari<const_iterator,const_iterator>	access:public	signature:(const key_type & x) const
equal_range	contains/multiset.hpp	/^    pair<iterator, iterator> equal_range(const key_type &x) const { return t.equal_range(x); }$/;"	f	class:ich::multiset	typeref:typename:pair<iterator,iterator>	access:public	signature:(const key_type & x) const
equal_range	contains/rb_tree.hpp	/^    pair<const_iterator, const_iterator> equal_range(const Key &k) const { return pair<const_ite/;"	f	class:ich::rb_tree	typeref:typename:pair<const_iterator,const_iterator>	access:public	signature:(const Key & k) const
equal_range	contains/rb_tree.hpp	/^    pair<iterator, iterator> equal_range(const Key &k) { return pair<iterator, iterator>(lower_b/;"	f	class:ich::rb_tree	typeref:typename:pair<iterator,iterator>	access:public	signature:(const Key & k)
equal_range	contains/set.hpp	/^    pair<iterator, iterator> equal_range(const key_type &x) const { return t.equal_range(x); }$/;"	f	class:ich::set	typeref:typename:pair<iterator,iterator>	access:public	signature:(const key_type & x) const
equal_to	contains/algorithm.hpp	/^struct equal_to$/;"	s	namespace:ich
equals	contains/hashtable.hpp	/^    key_equal   equals;$/;"	m	class:ich::hashtable	typeref:typename:key_equal	access:private
erase	contains/deque.hpp	/^    iterator erase(iterator first, iterator last);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator first,iterator last)
erase	contains/deque.hpp	/^    iterator erase(iterator pos);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator pos)
erase	contains/deque.hpp	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator first,iterator last)
erase	contains/deque.hpp	/^deque<T, Alloc, BufSize>::erase(iterator pos) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator pos)
erase	contains/list_temp.hpp	/^    iterator erase(iterator position) {$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:(iterator position)
erase	contains/map.hpp	/^    size_type erase(const key_type &x) { return t.erase(x); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:(const key_type & x)
erase	contains/map.hpp	/^    void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(iterator first,iterator last)
erase	contains/map.hpp	/^    void erase(iterator position) { t.erase(position); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(iterator position)
erase	contains/multimap.hpp	/^    size_type erase(const key_type &x) { return t.erase(x); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:(const key_type & x)
erase	contains/multimap.hpp	/^    void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(iterator first,iterator last)
erase	contains/multimap.hpp	/^    void erase(iterator position) { t.erase(position); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(iterator position)
erase	contains/multiset.hpp	/^    size_type erase(const key_type &x) {$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:(const key_type & x)
erase	contains/multiset.hpp	/^    void erase(iterator first, iterator last) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(iterator first,iterator last)
erase	contains/multiset.hpp	/^    void erase(iterator position) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(iterator position)
erase	contains/rb_tree.hpp	/^    size_type erase(const Key &x);$/;"	p	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:(const Key & x)
erase	contains/rb_tree.hpp	/^    void erase(const Key *first, const Key *last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(const Key * first,const Key * last)
erase	contains/rb_tree.hpp	/^    void erase(iterator first, iterator last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(iterator first,iterator last)
erase	contains/rb_tree.hpp	/^    void erase(iterator position);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(iterator position)
erase	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key &x) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::size_type	signature:(const Key & x)
erase	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(iterator first,iterator last)
erase	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(iterator position)
erase	contains/set.hpp	/^    size_type erase(const key_type &x) {$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:(const key_type & x)
erase	contains/set.hpp	/^    void erase(iterator first, iterator last) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(iterator first,iterator last)
erase	contains/set.hpp	/^    void erase(iterator position) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(iterator position)
erase	contains/slist.hpp	/^    iterator erase(iterator it) {$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:(iterator it)
erase	contains/vector.hpp	/^    iterator erase(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:(iterator first,iterator last)
erase	contains/vector.hpp	/^    iterator erase(iterator position) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:(iterator position)
fill_initialize	contains/deque.hpp	/^    void fill_initialize(size_type n, const value_type &value);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type n,const value_type & value)
fill_initialize	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n, const value_type &value) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type n,const value_type & value)
fill_initialize	contains/vector.hpp	/^    void fill_initialize(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:(iterator first,iterator last)
fill_initialize	contains/vector.hpp	/^    void fill_initialize(size_type n, const T &value) {$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:(size_type n,const T & value)
find	confusing_syntax/function_ret.cpp	/^InputIterator find(InputIterator first, InputIterator last, const T &value) {$/;"	f	typeref:typename:InputIterator	signature:(InputIterator first,InputIterator last,const T & value)
find	contains/algorithm.hpp	/^InputIt find(InputIt first, InputIt last, const T& value)$/;"	f	namespace:ich	typeref:typename:InputIt	signature:(InputIt first,InputIt last,const T & value)
find	contains/hashtable.hpp	/^    iterator find(const key_type &key) {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const key_type & key)
find	contains/map.hpp	/^    const_iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
find	contains/map.hpp	/^    iterator find(const key_type &x) { return t.find(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
find	contains/multimap.hpp	/^    const_iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
find	contains/multimap.hpp	/^    iterator find(const key_type &x) { return t.find(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
find	contains/multiset.hpp	/^    iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
find	contains/rb_tree.hpp	/^    iterator find(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k) const
find	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k) const
find	contains/set.hpp	/^    iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
finish	contains/deque.hpp	/^    iterator finish;$/;"	m	class:ich::deque	typeref:typename:iterator	access:protected
finish	contains/vector.hpp	/^    iterator finish;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
first	contains/deque.hpp	/^    T *first;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
first	contains/pair.hpp	/^    T1 first;$/;"	m	struct:ich::pair	typeref:typename:T1	access:public
first_type	contains/pair.hpp	/^    typedef T1 first_type;$/;"	t	struct:ich::pair	typeref:typename:T1	access:public
for_each	confusing_syntax/function_ret.cpp	/^Function for_each(InputIterator first, InputIterator last, Function f) {$/;"	f	typeref:typename:Function	signature:(InputIterator first,InputIterator last,Function f)
forward_iterator_tag	allocator/iterator.hpp	/^struct forward_iterator_tag : public input_iterator_tag {};$/;"	s	namespace:ich	inherits:input_iterator_tag
free_list	allocator/alloc.hpp	/^    static obj *volatile free_list[__NFREELISTS];$/;"	m	class:ich::__default_alloc_template	typeref:typename:obj * volatile[]	access:private
free_list	allocator/alloc.hpp	/^__default_alloc_template<threads, inst>::free_list[__NFREELISTS] =$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:__default_alloc_template<threads,inst>::obj * volatile[]
free_list_link	allocator/alloc.hpp	/^        union obj *free_list_link;$/;"	m	union:ich::__default_alloc_template::obj	typeref:union:obj *	access:public
freelist_index	allocator/alloc.hpp	/^    static size_t freelist_index(size_t bytes) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:size_t	access:private	signature:(size_t bytes)
front	contains/deque.hpp	/^    reference front() { return *start; }$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:()
front	contains/list_temp.hpp	/^    reference front() { return *begin(); }$/;"	f	class:ich::list	typeref:typename:reference	access:public	signature:()
front	contains/queue.hpp	/^    reference front() { return c.front(); }$/;"	f	class:ich::queue	typeref:typename:reference	access:public	signature:()
front	contains/slist.hpp	/^    reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:ich::slist	typeref:typename:reference	access:public	signature:()
front	contains/vector.hpp	/^    reference front() { return *begin(); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:()
func	allocator/test.cpp	/^typename iterator_traits<T>::value_type func(T ite) {$/;"	f	typeref:typename:iterator_traits<T>::value_type	signature:(T ite)
get_key	contains/hashtable.hpp	/^    ExtractKey  get_key;$/;"	m	class:ich::hashtable	typeref:typename:ExtractKey	access:private
get_node	contains/list_temp.hpp	/^    link_type get_node() { return (link_type)list_node_allocator::allocate(); }$/;"	f	class:ich::list	typeref:typename:link_type	access:protected	signature:()
get_node	contains/rb_tree.hpp	/^    link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:()
greater	contains/algorithm.hpp	/^struct greater$/;"	s	namespace:ich
has_trivial_assignment_operator	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_assignment_operator;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
has_trivial_assignment_operator	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_assignment_operator;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
has_trivial_copy_constructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_copy_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
has_trivial_copy_constructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_copy_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
has_trivial_default_constructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_default_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
has_trivial_default_constructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_default_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
has_trivial_destructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_destructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
has_trivial_destructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_destructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
hash	contains/hash_fun.hpp	/^struct hash { };$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<char*>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<char>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<const char*>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<int>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<long long>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<long>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<short>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<signed char>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<unsigned char>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<unsigned int>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<unsigned long long>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<unsigned long>$/;"	s	namespace:ich
hash	contains/hash_fun.hpp	/^struct hash<unsigned short>$/;"	s	namespace:ich
hash	contains/hashtable.hpp	/^    hasher      hash;$/;"	m	class:ich::hashtable	typeref:typename:hasher	access:private
hasher	contains/hashtable.hpp	/^    typedef HashFcn hasher;$/;"	t	class:ich::hashtable	typeref:typename:HashFcn	access:public
hashtable	contains/hashtable.hpp	/^    hashtable(size_type n, const HashFcn &hf, const EqualKey &eql) : hash(hf), equals(eql), get_/;"	f	class:ich::hashtable	access:public	signature:(size_type n,const HashFcn & hf,const EqualKey & eql)
hashtable	contains/hashtable.hpp	/^    typedef ich::hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>                hash/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:ich::hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
hashtable	contains/hashtable.hpp	/^    typedef ich::hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>                hash/;"	t	struct:ich::__hashtable_iterator	typeref:typename:ich::hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
hashtable	contains/hashtable.hpp	/^class hashtable$/;"	c	namespace:ich
hashtable_test	contains/test.cpp	/^void hashtable_test() {$/;"	f	typeref:typename:void	signature:()
head	contains/slist.hpp	/^    list_node_base head;$/;"	m	class:ich::slist	typeref:typename:list_node_base	access:private
header	contains/rb_tree.hpp	/^    link_type   header;$/;"	m	class:ich::rb_tree	typeref:typename:link_type	access:protected
heap_size	allocator/alloc.hpp	/^    static size_t heap_size;$/;"	m	class:ich::__default_alloc_template	typeref:typename:size_t	access:private
heap_size	allocator/alloc.hpp	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:size_t
heap_test	contains/test.cpp	/^void heap_test() {$/;"	f	typeref:typename:void	signature:()
ht	contains/hashtable.hpp	/^    const hashtable *ht;$/;"	m	struct:ich::__hashtable_const_iterator	typeref:typename:const hashtable *	access:public
ht	contains/hashtable.hpp	/^    hashtable *ht;$/;"	m	struct:ich::__hashtable_iterator	typeref:typename:hashtable *	access:public
ich	allocator/__type_traits.hpp	/^namespace ich {$/;"	n
ich	allocator/alloc.hpp	/^namespace ich {$/;"	n
ich	allocator/allocator.hpp	/^namespace ich$/;"	n
ich	allocator/constructor.hpp	/^namespace ich {$/;"	n
ich	allocator/iterator.hpp	/^namespace ich {$/;"	n
ich	allocator/uninitialized.hpp	/^namespace ich {$/;"	n
ich	contains/algorithm.hpp	/^namespace ich {$/;"	n
ich	contains/deque.hpp	/^namespace ich$/;"	n
ich	contains/hash_fun.hpp	/^namespace ich$/;"	n
ich	contains/hashtable.hpp	/^namespace ich$/;"	n
ich	contains/list.hpp	/^namespace ich$/;"	n
ich	contains/list_temp.hpp	/^namespace ich$/;"	n
ich	contains/map.hpp	/^namespace ich$/;"	n
ich	contains/multimap.hpp	/^namespace ich$/;"	n
ich	contains/multiset.hpp	/^namespace ich$/;"	n
ich	contains/pair.hpp	/^namespace ich$/;"	n
ich	contains/priority_queue.hpp	/^namespace ich$/;"	n
ich	contains/queue.hpp	/^namespace ich$/;"	n
ich	contains/rb_tree.hpp	/^namespace ich$/;"	n
ich	contains/set.hpp	/^namespace ich$/;"	n
ich	contains/slist.hpp	/^namespace ich$/;"	n
ich	contains/stack.hpp	/^namespace ich {$/;"	n
ich	contains/vector.hpp	/^namespace ich {$/;"	n
ich::__ALIGN	allocator/alloc.hpp	/^enum { __ALIGN = 8 };$/;"	e	enum:ich::__anon22e991b60103	access:public
ich::__MAX_BYTES	allocator/alloc.hpp	/^enum { __MAX_BYTES = 128 };$/;"	e	enum:ich::__anon22e991b60203	access:public
ich::__NFREELISTS	allocator/alloc.hpp	/^enum { __NFREELISTS = __MAX_BYTES \/ __ALIGN };$/;"	e	enum:ich::__anon22e991b60303	access:public
ich::__adjust_heap	contains/algorithm.hpp	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance len,T value)
ich::__adjust_heap	contains/algorithm.hpp	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value, Compar/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance len,T value,Compare comp)
ich::__advance	allocator/iterator.hpp	/^inline void __advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(BidirectionalIterator & i,Distance n,bidirectional_iterator_tag)
ich::__advance	allocator/iterator.hpp	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator & i,Distance n,input_iterator_tag)
ich::__advance	allocator/iterator.hpp	/^inline void __advance(RandomAccessIterator& i, Distance n, random_access_iterator_tag) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator & i,Distance n,random_access_iterator_tag)
ich::__anon22e991b60103	allocator/alloc.hpp	/^enum { __ALIGN = 8 };$/;"	g	namespace:ich
ich::__anon22e991b60203	allocator/alloc.hpp	/^enum { __MAX_BYTES = 128 };$/;"	g	namespace:ich
ich::__anon22e991b60303	allocator/alloc.hpp	/^enum { __NFREELISTS = __MAX_BYTES \/ __ALIGN };$/;"	g	namespace:ich
ich::__default_alloc_template	allocator/alloc.hpp	/^class __default_alloc_template$/;"	c	namespace:ich
ich::__default_alloc_template::allocate	allocator/alloc.hpp	/^    static void* allocate(size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void *	access:public	signature:(size_t n)
ich::__default_alloc_template::chunk_alloc	allocator/alloc.hpp	/^    static char* chunk_alloc(size_t size, int &nobjs);$/;"	p	class:ich::__default_alloc_template	typeref:typename:char *	access:private	signature:(size_t size,int & nobjs)
ich::__default_alloc_template::chunk_alloc	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::chunk_alloc(size_t size, int &nobjs) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:char *	signature:(size_t size,int & nobjs)
ich::__default_alloc_template::deallocate	allocator/alloc.hpp	/^    static void deallocate(void *p, size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void	access:public	signature:(void * p,size_t n)
ich::__default_alloc_template::end_free	allocator/alloc.hpp	/^    static char *end_free;      \/\/ 内存池结束位置$/;"	m	class:ich::__default_alloc_template	typeref:typename:char *	access:private
ich::__default_alloc_template::free_list	allocator/alloc.hpp	/^    static obj *volatile free_list[__NFREELISTS];$/;"	m	class:ich::__default_alloc_template	typeref:typename:obj * volatile[]	access:private
ich::__default_alloc_template::freelist_index	allocator/alloc.hpp	/^    static size_t freelist_index(size_t bytes) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:size_t	access:private	signature:(size_t bytes)
ich::__default_alloc_template::heap_size	allocator/alloc.hpp	/^    static size_t heap_size;$/;"	m	class:ich::__default_alloc_template	typeref:typename:size_t	access:private
ich::__default_alloc_template::obj	allocator/alloc.hpp	/^    union obj {$/;"	u	class:ich::__default_alloc_template	access:private
ich::__default_alloc_template::obj::client_data	allocator/alloc.hpp	/^        char client_data[1];    \/\/ 对客户可见的$/;"	m	union:ich::__default_alloc_template::obj	typeref:typename:char[1]	access:public
ich::__default_alloc_template::obj::free_list_link	allocator/alloc.hpp	/^        union obj *free_list_link;$/;"	m	union:ich::__default_alloc_template::obj	typeref:union:obj *	access:public
ich::__default_alloc_template::reallocate	allocator/alloc.hpp	/^    static void* reallocate(void *p, size_t old_sz, size_t new_sz);$/;"	p	class:ich::__default_alloc_template	typeref:typename:void *	access:public	signature:(void * p,size_t old_sz,size_t new_sz)
ich::__default_alloc_template::refill	allocator/alloc.hpp	/^    static void* refill(size_t n);$/;"	p	class:ich::__default_alloc_template	typeref:typename:void *	access:private	signature:(size_t n)
ich::__default_alloc_template::refill	allocator/alloc.hpp	/^void* __default_alloc_template<threads, inst>::refill(size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void *	signature:(size_t n)
ich::__default_alloc_template::round_up	allocator/alloc.hpp	/^    static size_t round_up(size_t bytes) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:size_t	access:private	signature:(size_t bytes)
ich::__default_alloc_template::start_free	allocator/alloc.hpp	/^    static char *start_free;    \/\/ 内存池开始位置$/;"	m	class:ich::__default_alloc_template	typeref:typename:char *	access:private
ich::__default_alloc_template<threads, inst>::end_free	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:char *
ich::__default_alloc_template<threads, inst>::free_list	allocator/alloc.hpp	/^__default_alloc_template<threads, inst>::free_list[__NFREELISTS] =$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:__default_alloc_template<threads,inst>::obj * volatile[]
ich::__default_alloc_template<threads, inst>::heap_size	allocator/alloc.hpp	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:size_t
ich::__default_alloc_template<threads, inst>::start_free	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:char *
ich::__deque_buf_size	contains/deque.hpp	/^inline size_t __deque_buf_size(size_t n, size_t sz) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(size_t n,size_t sz)
ich::__deque_iterator	contains/deque.hpp	/^struct __deque_iterator {$/;"	s	namespace:ich
ich::__deque_iterator::buffer_size	contains/deque.hpp	/^    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:size_t	access:public	signature:()
ich::__deque_iterator::const_iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,const T &,const T *,BufSiz>	access:public
ich::__deque_iterator::cur	contains/deque.hpp	/^    T *cur;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
ich::__deque_iterator::difference_type	contains/deque.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:ptrdiff_t	access:public
ich::__deque_iterator::first	contains/deque.hpp	/^    T *first;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
ich::__deque_iterator::iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	access:public
ich::__deque_iterator::iterator_category	contains/deque.hpp	/^    typedef random_access_iterator_tag  iterator_category;$/;"	t	struct:ich::__deque_iterator	typeref:typename:random_access_iterator_tag	access:public
ich::__deque_iterator::last	contains/deque.hpp	/^    T *last;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
ich::__deque_iterator::map_pointer	contains/deque.hpp	/^    typedef pointer*            map_pointer;$/;"	t	struct:ich::__deque_iterator	typeref:typename:pointer *	access:public
ich::__deque_iterator::node	contains/deque.hpp	/^    map_pointer node;$/;"	m	struct:ich::__deque_iterator	typeref:typename:map_pointer	access:public
ich::__deque_iterator::operator !=	contains/deque.hpp	/^    bool operator!=(const self &x) const { return !(*this == x); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__deque_iterator::operator *	contains/deque.hpp	/^    reference operator*() const { return *cur; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:reference	access:public	signature:() const
ich::__deque_iterator::operator +	contains/deque.hpp	/^    self operator+(difference_type n) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(difference_type n) const
ich::__deque_iterator::operator ++	contains/deque.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(int)
ich::__deque_iterator::operator ++	contains/deque.hpp	/^    self& operator++() {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:()
ich::__deque_iterator::operator +=	contains/deque.hpp	/^    self& operator+=(difference_type n) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:(difference_type n)
ich::__deque_iterator::operator -	contains/deque.hpp	/^    difference_type operator-(const self &x) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:difference_type	access:public	signature:(const self & x) const
ich::__deque_iterator::operator -	contains/deque.hpp	/^    self operator-(difference_type n) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(difference_type n) const
ich::__deque_iterator::operator --	contains/deque.hpp	/^    self operator--(int) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(int)
ich::__deque_iterator::operator --	contains/deque.hpp	/^    self& operator--() {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:()
ich::__deque_iterator::operator -=	contains/deque.hpp	/^    self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:(difference_type n)
ich::__deque_iterator::operator ->	contains/deque.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__deque_iterator::operator <	contains/deque.hpp	/^    bool operator<(const self &x) const { return (node == x.node) ? (cur < x.cur) : (node < x.no/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__deque_iterator::operator ==	contains/deque.hpp	/^    bool operator==(const self &x) const { return cur == x.cur; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__deque_iterator::operator []	contains/deque.hpp	/^    reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:reference	access:public	signature:(difference_type n) const
ich::__deque_iterator::pointer	contains/deque.hpp	/^    typedef Ptr                 pointer;$/;"	t	struct:ich::__deque_iterator	typeref:typename:Ptr	access:public
ich::__deque_iterator::reference	contains/deque.hpp	/^    typedef Ref                 reference;$/;"	t	struct:ich::__deque_iterator	typeref:typename:Ref	access:public
ich::__deque_iterator::self	contains/deque.hpp	/^    typedef __deque_iterator<T, Ref, Ptr, BufSiz>           self;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,Ref,Ptr,BufSiz>	access:public
ich::__deque_iterator::set_node	contains/deque.hpp	/^    void set_node(map_pointer new_node) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:void	access:public	signature:(map_pointer new_node)
ich::__deque_iterator::size_type	contains/deque.hpp	/^    typedef size_t              size_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:size_t	access:public
ich::__deque_iterator::value_type	contains/deque.hpp	/^    typedef T                   value_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:T	access:public
ich::__destroy	allocator/constructor.hpp	/^inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,T *)
ich::__destroy_aux	allocator/constructor.hpp	/^inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,__false_type)
ich::__destroy_aux	allocator/constructor.hpp	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator,ForwardIterator,__true_type)
ich::__distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type __distance(InputIterator first, /;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last,input_iterator_tag)
ich::__distance	allocator/iterator.hpp	/^inline typename iterator_traits<RandomAccessIterator>::difference_type __distance(RandomAccessIt/;"	f	namespace:ich	typeref:typename:iterator_traits<RandomAccessIterator>::difference_type	signature:(RandomAccessIterator first,RandomAccessIterator last,random_access_iterator_tag)
ich::__distance	allocator/iterator.hpp	/^inline void __distance(InputIterator first, InputIterator last, Distance &n, input_iterator_tag)/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator first,InputIterator last,Distance & n,input_iterator_tag)
ich::__distance	allocator/iterator.hpp	/^inline void __distance(RandomAccessIterator first, RandomAccessIterator last, Distance &n, rando/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance & n,random_access_iterator_tag tag)
ich::__false_type	allocator/__type_traits.hpp	/^struct __false_type { };$/;"	s	namespace:ich
ich::__hashtable_const_iterator	contains/hashtable.hpp	/^struct __hashtable_const_iterator$/;"	s	namespace:ich
ich::__hashtable_const_iterator::__hashtable_const_iterator	contains/hashtable.hpp	/^    __hashtable_const_iterator() {}$/;"	f	struct:ich::__hashtable_const_iterator	access:public	signature:()
ich::__hashtable_const_iterator::__hashtable_const_iterator	contains/hashtable.hpp	/^    __hashtable_const_iterator(node *n, hashtable *tab) : cur(n), ht(tab) {}$/;"	f	struct:ich::__hashtable_const_iterator	access:public	signature:(node * n,hashtable * tab)
ich::__hashtable_const_iterator::const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>    cons/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_const_iterator::cur	contains/hashtable.hpp	/^    const node *cur;$/;"	m	struct:ich::__hashtable_const_iterator	typeref:typename:const node *	access:public
ich::__hashtable_const_iterator::difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t               difference_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:ptrdiff_t	access:public
ich::__hashtable_const_iterator::hashtable	contains/hashtable.hpp	/^    typedef ich::hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>                hash/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:ich::hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_const_iterator::ht	contains/hashtable.hpp	/^    const hashtable *ht;$/;"	m	struct:ich::__hashtable_const_iterator	typeref:typename:const hashtable *	access:public
ich::__hashtable_const_iterator::iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>          iter/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_const_iterator::iterator_category	contains/hashtable.hpp	/^    typedef forward_iterator_tag    iterator_category;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:forward_iterator_tag	access:public
ich::__hashtable_const_iterator::node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_node<Value>	access:public
ich::__hashtable_const_iterator::operator !=	contains/hashtable.hpp	/^    bool operator!=(const iterator &it) const { return cur != it.cur; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
ich::__hashtable_const_iterator::operator *	contains/hashtable.hpp	/^    reference operator*() const { return cur->val; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:reference	access:public	signature:() const
ich::__hashtable_const_iterator::operator ++	contains/hashtable.hpp	/^    const_iterator operator++(int);$/;"	p	struct:ich::__hashtable_const_iterator	typeref:typename:const_iterator	access:public	signature:(int)
ich::__hashtable_const_iterator::operator ++	contains/hashtable.hpp	/^    const_iterator& operator++();$/;"	p	struct:ich::__hashtable_const_iterator	typeref:typename:const_iterator &	access:public	signature:()
ich::__hashtable_const_iterator::operator ++	contains/hashtable.hpp	/^__hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++() {$/;"	f	class:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc> &	signature:()
ich::__hashtable_const_iterator::operator ++	contains/hashtable.hpp	/^__hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++(int) {$/;"	f	class:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	signature:(int)
ich::__hashtable_const_iterator::operator ->	contains/hashtable.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__hashtable_const_iterator::operator ==	contains/hashtable.hpp	/^    bool operator==(const iterator &it) const { return cur == it.cur; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
ich::__hashtable_const_iterator::pointer	contains/hashtable.hpp	/^    typedef const Value*                  pointer;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:const Value *	access:public
ich::__hashtable_const_iterator::reference	contains/hashtable.hpp	/^    typedef const Value&                  reference;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:const Value &	access:public
ich::__hashtable_const_iterator::size_type	contains/hashtable.hpp	/^    typedef size_t                  size_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:size_t	access:public
ich::__hashtable_const_iterator::value_type	contains/hashtable.hpp	/^    typedef Value                   value_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:Value	access:public
ich::__hashtable_iterator	contains/hashtable.hpp	/^struct __hashtable_iterator$/;"	s	namespace:ich
ich::__hashtable_iterator::__hashtable_iterator	contains/hashtable.hpp	/^    __hashtable_iterator() {}$/;"	f	struct:ich::__hashtable_iterator	access:public	signature:()
ich::__hashtable_iterator::__hashtable_iterator	contains/hashtable.hpp	/^    __hashtable_iterator(node *n, hashtable *tab) : cur(n), ht(tab) {}$/;"	f	struct:ich::__hashtable_iterator	access:public	signature:(node * n,hashtable * tab)
ich::__hashtable_iterator::const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>    cons/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_iterator::cur	contains/hashtable.hpp	/^    node *cur;$/;"	m	struct:ich::__hashtable_iterator	typeref:typename:node *	access:public
ich::__hashtable_iterator::difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t               difference_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:ptrdiff_t	access:public
ich::__hashtable_iterator::hashtable	contains/hashtable.hpp	/^    typedef ich::hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>                hash/;"	t	struct:ich::__hashtable_iterator	typeref:typename:ich::hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_iterator::ht	contains/hashtable.hpp	/^    hashtable *ht;$/;"	m	struct:ich::__hashtable_iterator	typeref:typename:hashtable *	access:public
ich::__hashtable_iterator::iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>          iter/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::__hashtable_iterator::iterator_category	contains/hashtable.hpp	/^    typedef forward_iterator_tag    iterator_category;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:forward_iterator_tag	access:public
ich::__hashtable_iterator::node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_node<Value>	access:public
ich::__hashtable_iterator::operator !=	contains/hashtable.hpp	/^    bool operator!=(const iterator &it) const { return cur != it.cur; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
ich::__hashtable_iterator::operator *	contains/hashtable.hpp	/^    reference operator*() const { return cur->val; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:reference	access:public	signature:() const
ich::__hashtable_iterator::operator ++	contains/hashtable.hpp	/^    iterator operator++(int);$/;"	p	struct:ich::__hashtable_iterator	typeref:typename:iterator	access:public	signature:(int)
ich::__hashtable_iterator::operator ++	contains/hashtable.hpp	/^    iterator& operator++();$/;"	p	struct:ich::__hashtable_iterator	typeref:typename:iterator &	access:public	signature:()
ich::__hashtable_iterator::operator ++	contains/hashtable.hpp	/^__hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++() {$/;"	f	class:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc> &	signature:()
ich::__hashtable_iterator::operator ++	contains/hashtable.hpp	/^__hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++(int) {$/;"	f	class:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	signature:(int)
ich::__hashtable_iterator::operator ->	contains/hashtable.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__hashtable_iterator::operator ==	contains/hashtable.hpp	/^    bool operator==(const iterator &it) const { return cur == it.cur; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
ich::__hashtable_iterator::pointer	contains/hashtable.hpp	/^    typedef Value*                  pointer;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value *	access:public
ich::__hashtable_iterator::reference	contains/hashtable.hpp	/^    typedef Value&                  reference;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value &	access:public
ich::__hashtable_iterator::size_type	contains/hashtable.hpp	/^    typedef size_t                  size_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:size_t	access:public
ich::__hashtable_iterator::value_type	contains/hashtable.hpp	/^    typedef Value                   value_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value	access:public
ich::__hashtable_node	contains/hashtable.hpp	/^struct __hashtable_node$/;"	s	namespace:ich
ich::__hashtable_node::next	contains/hashtable.hpp	/^    __hashtable_node *next;$/;"	m	struct:ich::__hashtable_node	typeref:typename:__hashtable_node *	access:public
ich::__hashtable_node::val	contains/hashtable.hpp	/^    Value val;$/;"	m	struct:ich::__hashtable_node	typeref:typename:Value	access:public
ich::__list_iterator	contains/list.hpp	/^struct __list_iterator {$/;"	s	namespace:ich
ich::__list_iterator	contains/list_temp.hpp	/^struct __list_iterator {$/;"	s	namespace:ich
ich::__list_iterator::__list_iterator	contains/list.hpp	/^    __list_iterator() {}$/;"	f	struct:ich::__list_iterator	access:public	signature:()
ich::__list_iterator::__list_iterator	contains/list.hpp	/^    __list_iterator(const iterator &x) : node(x.node) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(const iterator & x)
ich::__list_iterator::__list_iterator	contains/list.hpp	/^    __list_iterator(link_type x) : node(x) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(link_type x)
ich::__list_iterator::__list_iterator	contains/list_temp.hpp	/^    __list_iterator() {}$/;"	f	struct:ich::__list_iterator	access:public	signature:()
ich::__list_iterator::__list_iterator	contains/list_temp.hpp	/^    __list_iterator(const iterator &x) : node(x.node) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(const iterator & x)
ich::__list_iterator::__list_iterator	contains/list_temp.hpp	/^    __list_iterator(link_type x) : node(x) {}$/;"	f	struct:ich::__list_iterator	access:public	signature:(link_type x)
ich::__list_iterator::difference_type	contains/list.hpp	/^    typedef ptrdiff_t       difference_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:ptrdiff_t	access:public
ich::__list_iterator::difference_type	contains/list_temp.hpp	/^    typedef ptrdiff_t       difference_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:ptrdiff_t	access:public
ich::__list_iterator::iterator	contains/list.hpp	/^    typedef __list_iterator<T, T&, T*>      iterator;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T,T &,T * >	access:public
ich::__list_iterator::iterator	contains/list_temp.hpp	/^    typedef __list_iterator<T> iterator;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T>	access:public
ich::__list_iterator::iterator_category	contains/list.hpp	/^    typedef bidirectional_iterator_tag  iterator_category;$/;"	t	struct:ich::__list_iterator	typeref:typename:bidirectional_iterator_tag	access:public
ich::__list_iterator::iterator_category	contains/list_temp.hpp	/^    typedef bidirectional_iterator_tag  iterator_category;$/;"	t	struct:ich::__list_iterator	typeref:typename:bidirectional_iterator_tag	access:public
ich::__list_iterator::link_type	contains/list.hpp	/^    typedef __list_node<T>* link_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_node<T> *	access:public
ich::__list_iterator::link_type	contains/list_temp.hpp	/^    typedef __list_node<T>* link_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_node<T> *	access:public
ich::__list_iterator::node	contains/list.hpp	/^    link_type node;$/;"	m	struct:ich::__list_iterator	typeref:typename:link_type	access:public
ich::__list_iterator::node	contains/list_temp.hpp	/^    link_type node;$/;"	m	struct:ich::__list_iterator	typeref:typename:link_type	access:public
ich::__list_iterator::operator !=	contains/list.hpp	/^    bool operator!=(const self &x) const { return node != x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__list_iterator::operator !=	contains/list_temp.hpp	/^    bool operator!=(const self &x) const { return node != x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__list_iterator::operator *	contains/list.hpp	/^    reference operator*() const { return (*node).data; }$/;"	f	struct:ich::__list_iterator	typeref:typename:reference	access:public	signature:() const
ich::__list_iterator::operator *	contains/list_temp.hpp	/^    reference operator*() const { return (*node).data; }$/;"	f	struct:ich::__list_iterator	typeref:typename:reference	access:public	signature:() const
ich::__list_iterator::operator ++	contains/list.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self	access:public	signature:(int)
ich::__list_iterator::operator ++	contains/list.hpp	/^    self& operator++() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
ich::__list_iterator::operator ++	contains/list_temp.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self	access:public	signature:(int)
ich::__list_iterator::operator ++	contains/list_temp.hpp	/^    self& operator++() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
ich::__list_iterator::operator --	contains/list.hpp	/^    self& operator--() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
ich::__list_iterator::operator --	contains/list.hpp	/^    self& operator--(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:(int)
ich::__list_iterator::operator --	contains/list_temp.hpp	/^    self& operator--() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
ich::__list_iterator::operator --	contains/list_temp.hpp	/^    self& operator--(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:(int)
ich::__list_iterator::operator ->	contains/list.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__list_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__list_iterator::operator ->	contains/list_temp.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__list_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__list_iterator::operator ==	contains/list.hpp	/^    bool operator==(const self &x) const { return node == x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__list_iterator::operator ==	contains/list_temp.hpp	/^    bool operator==(const self &x) const { return node == x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
ich::__list_iterator::pointer	contains/list.hpp	/^    typedef Ptr             pointer;$/;"	t	struct:ich::__list_iterator	typeref:typename:Ptr	access:public
ich::__list_iterator::pointer	contains/list_temp.hpp	/^    typedef T*              pointer;$/;"	t	struct:ich::__list_iterator	typeref:typename:T *	access:public
ich::__list_iterator::reference	contains/list.hpp	/^    typedef Ref             reference;$/;"	t	struct:ich::__list_iterator	typeref:typename:Ref	access:public
ich::__list_iterator::reference	contains/list_temp.hpp	/^    typedef T&              reference;$/;"	t	struct:ich::__list_iterator	typeref:typename:T &	access:public
ich::__list_iterator::self	contains/list.hpp	/^    typedef __list_iterator<T, Ref, Ptr>    self;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T,Ref,Ptr>	access:public
ich::__list_iterator::self	contains/list_temp.hpp	/^    typedef __list_iterator<T> self;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T>	access:public
ich::__list_iterator::size_type	contains/list.hpp	/^    typedef size_t          size_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:size_t	access:public
ich::__list_iterator::size_type	contains/list_temp.hpp	/^    typedef size_t          size_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:size_t	access:public
ich::__list_iterator::value_type	contains/list.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:T	access:public
ich::__list_iterator::value_type	contains/list_temp.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:T	access:public
ich::__list_node	contains/list.hpp	/^struct __list_node {$/;"	s	namespace:ich
ich::__list_node	contains/list_temp.hpp	/^struct __list_node {$/;"	s	namespace:ich
ich::__list_node::data	contains/list.hpp	/^    T data;$/;"	m	struct:ich::__list_node	typeref:typename:T	access:public
ich::__list_node::data	contains/list_temp.hpp	/^    T data;$/;"	m	struct:ich::__list_node	typeref:typename:T	access:public
ich::__list_node::next	contains/list.hpp	/^    void_pointer next;$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
ich::__list_node::next	contains/list_temp.hpp	/^    void_pointer next;$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
ich::__list_node::prev	contains/list.hpp	/^    void_pointer prev;  \/\/ __list_node<T>*$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
ich::__list_node::prev	contains/list_temp.hpp	/^    void_pointer prev;  \/\/ __list_node<T>*$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
ich::__list_node::void_pointer	contains/list.hpp	/^    typedef void *void_pointer;$/;"	t	struct:ich::__list_node	typeref:typename:void *	access:public
ich::__list_node::void_pointer	contains/list_temp.hpp	/^    typedef void *void_pointer;$/;"	t	struct:ich::__list_node	typeref:typename:void *	access:public
ich::__lower_bound	contains/algorithm.hpp	/^ForwardIterator __lower_bound (ForwardIterator first, ForwardIterator last, const T& value, Comp/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Compare comp,Distance *,forward_iterator_tag)
ich::__lower_bound	contains/algorithm.hpp	/^ForwardIterator __lower_bound (ForwardIterator first, ForwardIterator last, const T& value, Dist/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Distance *,forward_iterator_tag)
ich::__lower_bound	contains/algorithm.hpp	/^RandomAccessIterator __lower_bound (RandomAccessIterator first, RandomAccessIterator last, const/;"	f	namespace:ich	typeref:typename:RandomAccessIterator	signature:(RandomAccessIterator first,RandomAccessIterator last,const T & value,Compare comp,Distance *,random_access_iterator_tag)
ich::__lower_bound	contains/algorithm.hpp	/^RandomAccessIterator __lower_bound (RandomAccessIterator first, RandomAccessIterator last, const/;"	f	namespace:ich	typeref:typename:RandomAccessIterator	signature:(RandomAccessIterator first,RandomAccessIterator last,const T & value,Distance *,random_access_iterator_tag)
ich::__make_heap	contains/algorithm.hpp	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T *, Distance *) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Distance *)
ich::__make_heap	contains/algorithm.hpp	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T *, Distance *, Compare/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Distance *,Compare comp)
ich::__malloc_alloc_template	allocator/alloc.hpp	/^class __malloc_alloc_template$/;"	c	namespace:ich
ich::__malloc_alloc_template	allocator/alloc.hpp	/^void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;$/;"	v	namespace:ich	typeref:typename:void (* <inst>::__malloc_alloc_oom_handler)()
ich::__malloc_alloc_template::__malloc_alloc_oom_handler	allocator/alloc.hpp	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:ich::__malloc_alloc_template	typeref:typename:void (*)()	access:private
ich::__malloc_alloc_template::allocate	allocator/alloc.hpp	/^    static void* allocate(size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	access:public	signature:(size_t n)
ich::__malloc_alloc_template::deallocate	allocator/alloc.hpp	/^    static void deallocate(void *p, size_t \/* n *\/) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void	access:public	signature:(void * p,size_t)
ich::__malloc_alloc_template::oom_malloc	allocator/alloc.hpp	/^    static void *oom_malloc(size_t);$/;"	p	class:ich::__malloc_alloc_template	typeref:typename:void *	access:private	signature:(size_t)
ich::__malloc_alloc_template::oom_malloc	allocator/alloc.hpp	/^void* __malloc_alloc_template<inst>::oom_malloc(size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	signature:(size_t n)
ich::__malloc_alloc_template::oom_realloc	allocator/alloc.hpp	/^    static void *oom_realloc(void *, size_t);$/;"	p	class:ich::__malloc_alloc_template	typeref:typename:void *	access:private	signature:(void *,size_t)
ich::__malloc_alloc_template::oom_realloc	allocator/alloc.hpp	/^void* __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	signature:(void * p,size_t n)
ich::__malloc_alloc_template::reallocate	allocator/alloc.hpp	/^    static void* reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	access:public	signature:(void * p,size_t,size_t new_sz)
ich::__malloc_alloc_template::set_malloc_handler	allocator/alloc.hpp	/^    static void (*set_malloc_handler(void (* f)())) ()$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void (*)()	access:public	signature:(void (* f)())
ich::__pop_heap	contains/algorithm.hpp	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterat/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,RandomAccessIterator result,T value,Distance *)
ich::__pop_heap	contains/algorithm.hpp	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterat/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,RandomAccessIterator result,T value,Distance *,Compare comp)
ich::__pop_heap_aux	contains/algorithm.hpp	/^inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *)
ich::__pop_heap_aux	contains/algorithm.hpp	/^inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*, Compare co/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,T *,Compare comp)
ich::__push_heap	contains/algorithm.hpp	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance topIndex,T value)
ich::__push_heap	contains/algorithm.hpp	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value, Com/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,Distance holeIndex,Distance topIndex,T value,Compare comp)
ich::__push_heap_aux	contains/algorithm.hpp	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance *, T/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance *,T *)
ich::__push_heap_aux	contains/algorithm.hpp	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance *, T/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Distance *,T *,Compare comp)
ich::__rb_tree_base_iterator	contains/rb_tree.hpp	/^struct __rb_tree_base_iterator$/;"	s	namespace:ich
ich::__rb_tree_base_iterator::base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base::base_ptr   base_ptr;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:__rb_tree_node_base::base_ptr	access:public
ich::__rb_tree_base_iterator::decrement	contains/rb_tree.hpp	/^    void decrement() {$/;"	f	struct:ich::__rb_tree_base_iterator	typeref:typename:void	access:public	signature:()
ich::__rb_tree_base_iterator::difference_type	contains/rb_tree.hpp	/^    typedef ptrdiff_t                       difference_type;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:ptrdiff_t	access:public
ich::__rb_tree_base_iterator::increment	contains/rb_tree.hpp	/^    void increment() {$/;"	f	struct:ich::__rb_tree_base_iterator	typeref:typename:void	access:public	signature:()
ich::__rb_tree_base_iterator::iterator_category	contains/rb_tree.hpp	/^    typedef bidirectional_iterator_tag      iterator_category;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:bidirectional_iterator_tag	access:public
ich::__rb_tree_base_iterator::node	contains/rb_tree.hpp	/^    base_ptr node;$/;"	m	struct:ich::__rb_tree_base_iterator	typeref:typename:base_ptr	access:public
ich::__rb_tree_black	contains/rb_tree.hpp	/^const __rb_tree_color_type __rb_tree_black  = true; \/\/ 黑色为1$/;"	v	namespace:ich	typeref:typename:const __rb_tree_color_type
ich::__rb_tree_color_type	contains/rb_tree.hpp	/^typedef bool __rb_tree_color_type;$/;"	t	namespace:ich	typeref:typename:bool
ich::__rb_tree_iterator	contains/rb_tree.hpp	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s	namespace:ich	inherits:__rb_tree_base_iterator
ich::__rb_tree_iterator::__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator() {}$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:()
ich::__rb_tree_iterator::__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator(const iterator &it) { node = it.node; }$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:(const iterator & it)
ich::__rb_tree_iterator::__rb_tree_iterator	contains/rb_tree.hpp	/^    __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:ich::__rb_tree_iterator	access:public	signature:(link_type x)
ich::__rb_tree_iterator::const_iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, const Value&, const Value*>   const_iterator;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,const Value &,const Value * >	access:public
ich::__rb_tree_iterator::iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, Value&, Value*>               iterator;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,Value &,Value * >	access:public
ich::__rb_tree_iterator::link_type	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>*                                  link_type;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_node<Value> *	access:public
ich::__rb_tree_iterator::operator !=	contains/rb_tree.hpp	/^    bool operator!=(const self &x) { return !(*this == x); }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:bool	access:public	signature:(const self & x)
ich::__rb_tree_iterator::operator *	contains/rb_tree.hpp	/^    reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:reference	access:public	signature:() const
ich::__rb_tree_iterator::operator ++	contains/rb_tree.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self	access:public	signature:(int)
ich::__rb_tree_iterator::operator ++	contains/rb_tree.hpp	/^    self& operator++() { increment(); return *this; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self &	access:public	signature:()
ich::__rb_tree_iterator::operator --	contains/rb_tree.hpp	/^    self operator--(int) {$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self	access:public	signature:(int)
ich::__rb_tree_iterator::operator --	contains/rb_tree.hpp	/^    self& operator--() { decrement(); return *this; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self &	access:public	signature:()
ich::__rb_tree_iterator::operator ->	contains/rb_tree.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:pointer	access:public	signature:() const
ich::__rb_tree_iterator::operator ==	contains/rb_tree.hpp	/^    bool operator==(const self &x) { return node == x.node; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:bool	access:public	signature:(const self & x)
ich::__rb_tree_iterator::pointer	contains/rb_tree.hpp	/^    typedef Ptr     pointer;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Ptr	access:public
ich::__rb_tree_iterator::reference	contains/rb_tree.hpp	/^    typedef Ref     reference;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Ref	access:public
ich::__rb_tree_iterator::self	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, Ref, Ptr>                     self;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,Ref,Ptr>	access:public
ich::__rb_tree_iterator::value_type	contains/rb_tree.hpp	/^    typedef Value   value_type;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Value	access:public
ich::__rb_tree_node	contains/rb_tree.hpp	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s	namespace:ich	inherits:__rb_tree_node_base
ich::__rb_tree_node::link_type	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:ich::__rb_tree_node	typeref:typename:__rb_tree_node<Value> *	access:public
ich::__rb_tree_node::value_field	contains/rb_tree.hpp	/^    Value value_field; \/\/ 节点值$/;"	m	struct:ich::__rb_tree_node	typeref:typename:Value	access:public
ich::__rb_tree_node_base	contains/rb_tree.hpp	/^struct __rb_tree_node_base$/;"	s	namespace:ich
ich::__rb_tree_node_base::base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:ich::__rb_tree_node_base	typeref:typename:__rb_tree_node_base *	access:public
ich::__rb_tree_node_base::color	contains/rb_tree.hpp	/^    color_type  color;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:color_type	access:public
ich::__rb_tree_node_base::color_type	contains/rb_tree.hpp	/^    typedef __rb_tree_color_type color_type;$/;"	t	struct:ich::__rb_tree_node_base	typeref:typename:__rb_tree_color_type	access:public
ich::__rb_tree_node_base::left	contains/rb_tree.hpp	/^    base_ptr    left;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
ich::__rb_tree_node_base::maximum	contains/rb_tree.hpp	/^    static base_ptr maximum(base_ptr x) { while (x->right != 0) x = x->right; return x; }$/;"	f	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public	signature:(base_ptr x)
ich::__rb_tree_node_base::minimum	contains/rb_tree.hpp	/^    static base_ptr minimum(base_ptr x) { while (x->left != 0) x = x->left; return x; }$/;"	f	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public	signature:(base_ptr x)
ich::__rb_tree_node_base::parent	contains/rb_tree.hpp	/^    base_ptr    parent;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
ich::__rb_tree_node_base::right	contains/rb_tree.hpp	/^    base_ptr    right;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
ich::__rb_tree_rebalance	contains/rb_tree.hpp	/^inline void __rb_tree_rebalance(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
ich::__rb_tree_red	contains/rb_tree.hpp	/^const __rb_tree_color_type __rb_tree_red    = false;\/\/ 红色为0$/;"	v	namespace:ich	typeref:typename:const __rb_tree_color_type
ich::__rb_tree_rotate_left	contains/rb_tree.hpp	/^inline void __rb_tree_rotate_left(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
ich::__rb_tree_rotate_right	contains/rb_tree.hpp	/^inline void __rb_tree_rotate_right(__rb_tree_node_base *x, __rb_tree_node_base *&root) {$/;"	f	namespace:ich	typeref:typename:void	signature:(__rb_tree_node_base * x,__rb_tree_node_base * & root)
ich::__slist_iterator	contains/slist.hpp	/^struct __slist_iterator : public __slist_iterator_base$/;"	s	namespace:ich	inherits:__slist_iterator_base
ich::__slist_iterator::__slist_iterator	contains/slist.hpp	/^    __slist_iterator(): __slist_iterator_base(0) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:()
ich::__slist_iterator::__slist_iterator	contains/slist.hpp	/^    __slist_iterator(const iterator &x) : __slist_iterator_base(x.node) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:(const iterator & x)
ich::__slist_iterator::__slist_iterator	contains/slist.hpp	/^    __slist_iterator(list_node *x) : __slist_iterator_base(x) {}$/;"	f	struct:ich::__slist_iterator	access:public	signature:(list_node * x)
ich::__slist_iterator::const_iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,const T &,const T * >	access:public
ich::__slist_iterator::iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,T &,T * >	access:public
ich::__slist_iterator::list_node	contains/slist.hpp	/^    typedef __slist_node<T> list_node;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_node<T>	access:public
ich::__slist_iterator::operator *	contains/slist.hpp	/^    reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:ich::__slist_iterator	typeref:typename:reference	access:public	signature:() const
ich::__slist_iterator::operator ++	contains/slist.hpp	/^    self& operator++() {$/;"	f	struct:ich::__slist_iterator	typeref:typename:self &	access:public	signature:()
ich::__slist_iterator::operator ++	contains/slist.hpp	/^    self& operator++(int) {$/;"	f	struct:ich::__slist_iterator	typeref:typename:self &	access:public	signature:(int)
ich::__slist_iterator::operator ->	contains/slist.hpp	/^    reference operator->() const { return &(operator*()); }$/;"	f	struct:ich::__slist_iterator	typeref:typename:reference	access:public	signature:() const
ich::__slist_iterator::pointer	contains/slist.hpp	/^    typedef Ptr             pointer;$/;"	t	struct:ich::__slist_iterator	typeref:typename:Ptr	access:public
ich::__slist_iterator::reference	contains/slist.hpp	/^    typedef Ref             reference;$/;"	t	struct:ich::__slist_iterator	typeref:typename:Ref	access:public
ich::__slist_iterator::self	contains/slist.hpp	/^    typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,Ref,Ptr>	access:public
ich::__slist_iterator::value_type	contains/slist.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__slist_iterator	typeref:typename:T	access:public
ich::__slist_iterator_base	contains/slist.hpp	/^struct __slist_iterator_base$/;"	s	namespace:ich
ich::__slist_iterator_base::__slist_iterator_base	contains/slist.hpp	/^    __slist_iterator_base(__slist_node_base *x) : node(x) {}$/;"	f	struct:ich::__slist_iterator_base	access:public	signature:(__slist_node_base * x)
ich::__slist_iterator_base::difference_type	contains/slist.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:ptrdiff_t	access:public
ich::__slist_iterator_base::incr	contains/slist.hpp	/^    void incr() { node = node->next; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:void	access:public	signature:()
ich::__slist_iterator_base::iterator_category	contains/slist.hpp	/^    typedef forward_iterator_tag iterator_category;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:forward_iterator_tag	access:public
ich::__slist_iterator_base::node	contains/slist.hpp	/^    __slist_node_base *node;$/;"	m	struct:ich::__slist_iterator_base	typeref:typename:__slist_node_base *	access:public
ich::__slist_iterator_base::operator !=	contains/slist.hpp	/^    bool operator!=(const __slist_iterator_base &x) const { return node != x.node; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:bool	access:public	signature:(const __slist_iterator_base & x) const
ich::__slist_iterator_base::operator ==	contains/slist.hpp	/^    bool operator==(const __slist_iterator_base &x) const { return node == x.node; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:bool	access:public	signature:(const __slist_iterator_base & x) const
ich::__slist_iterator_base::size_type	contains/slist.hpp	/^    typedef size_t      size_type;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:size_t	access:public
ich::__slist_make_link	contains/slist.hpp	/^inline __slist_node_base* __slist_make_link(__slist_node_base *prev_node, __slist_node_base *new/;"	f	namespace:ich	typeref:typename:__slist_node_base *	signature:(__slist_node_base * prev_node,__slist_node_base * new_node)
ich::__slist_node	contains/slist.hpp	/^struct __slist_node : public __slist_node_base$/;"	s	namespace:ich	inherits:__slist_node_base
ich::__slist_node::data	contains/slist.hpp	/^    T data;$/;"	m	struct:ich::__slist_node	typeref:typename:T	access:public
ich::__slist_node_base	contains/slist.hpp	/^struct __slist_node_base$/;"	s	namespace:ich
ich::__slist_node_base::next	contains/slist.hpp	/^    __slist_node_base *next;$/;"	m	struct:ich::__slist_node_base	typeref:typename:__slist_node_base *	access:public
ich::__slist_size	contains/slist.hpp	/^inline size_t __slist_size(__slist_node_base *node) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(__slist_node_base * node)
ich::__stl_hash_string	contains/hash_fun.hpp	/^inline size_t __stl_hash_string(const char *s) {$/;"	f	namespace:ich	typeref:typename:size_t	signature:(const char * s)
ich::__stl_next_prime	contains/hashtable.hpp	/^inline unsigned long __stl_next_prime(unsigned long n) {$/;"	f	namespace:ich	typeref:typename:unsigned long	signature:(unsigned long n)
ich::__stl_num_primes	contains/hashtable.hpp	/^static const int __stl_num_primes = 28;$/;"	v	namespace:ich	typeref:typename:const int
ich::__stl_prime_list	contains/hashtable.hpp	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v	namespace:ich	typeref:typename:const unsigned long[]
ich::__true_type	allocator/__type_traits.hpp	/^struct __true_type { };$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^struct __type_traits<signed char> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<bool> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<char> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const signed char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<const unsigned char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<double> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<float> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<int> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long double> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long long> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<long> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<short> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<signed char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned char*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned char> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned int> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned long long> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned long> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<unsigned short> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <> struct __type_traits<wchar_t> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <class T> struct __type_traits<T*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <class T> struct __type_traits<const T*> {$/;"	s	namespace:ich
ich::__type_traits	allocator/__type_traits.hpp	/^template <class type> struct __type_traits {$/;"	s	namespace:ich
ich::__type_traits::has_trivial_assignment_operator	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_assignment_operator;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
ich::__type_traits::has_trivial_assignment_operator	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_assignment_operator;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__type_traits::has_trivial_copy_constructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_copy_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
ich::__type_traits::has_trivial_copy_constructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_copy_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__type_traits::has_trivial_default_constructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_default_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
ich::__type_traits::has_trivial_default_constructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_default_constructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__type_traits::has_trivial_destructor	allocator/__type_traits.hpp	/^    typedef __false_type has_trivial_destructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
ich::__type_traits::has_trivial_destructor	allocator/__type_traits.hpp	/^    typedef __true_type has_trivial_destructor;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__type_traits::is_POD_type	allocator/__type_traits.hpp	/^    typedef __false_type is_POD_type;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
ich::__type_traits::is_POD_type	allocator/__type_traits.hpp	/^    typedef __true_type is_POD_type;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__type_traits::this_dummy_member_must_be_first	allocator/__type_traits.hpp	/^    typedef __true_type this_dummy_member_must_be_first;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
ich::__uninitialized_copy	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy(InputIterator first, InputIterator last, ForwardIter/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,T *)
ich::__uninitialized_copy_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, Forward/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,__false_type)
ich::__uninitialized_copy_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, Forward/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result,__true_type)
ich::__uninitialized_fill	allocator/uninitialized.hpp	/^inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &x, T1 *) /;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,T1 *)
ich::__uninitialized_fill_aux	allocator/uninitialized.hpp	/^inline void __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T &x, __/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,__false_type)
ich::__uninitialized_fill_aux	allocator/uninitialized.hpp	/^inline void __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T &x, __/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x,__true_type)
ich::__uninitialized_fill_n	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, const T &x, T1 *) {$/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,T1 *)
ich::__uninitialized_fill_n_aux	allocator/uninitialized.hpp	/^ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, const T &x, __false_ty/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,__false_type)
ich::__uninitialized_fill_n_aux	allocator/uninitialized.hpp	/^inline ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, const T &x, __t/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x,__true_type)
ich::advance	allocator/iterator.hpp	/^inline void advance(InputIterator& i, Distance n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator & i,Distance n)
ich::allocator	allocator/allocator.hpp	/^class allocator$/;"	c	namespace:ich
ich::allocator::allocate	allocator/allocator.hpp	/^    static T* allocate() {$/;"	f	class:ich::allocator	typeref:typename:T *	access:public	signature:()
ich::allocator::allocate	allocator/allocator.hpp	/^    static T* allocate(size_t n) {$/;"	f	class:ich::allocator	typeref:typename:T *	access:public	signature:(size_t n)
ich::allocator::const_pointer	allocator/allocator.hpp	/^    typedef const T*        const_pointer;$/;"	t	class:ich::allocator	typeref:typename:const T *	access:public
ich::allocator::const_reference	allocator/allocator.hpp	/^    typedef const T&        const_reference;$/;"	t	class:ich::allocator	typeref:typename:const T &	access:public
ich::allocator::deallocate	allocator/allocator.hpp	/^    static void deallocate(T *ptr) {$/;"	f	class:ich::allocator	typeref:typename:void	access:public	signature:(T * ptr)
ich::allocator::deallocate	allocator/allocator.hpp	/^    static void deallocate(T *ptr, size_t n) {$/;"	f	class:ich::allocator	typeref:typename:void	access:public	signature:(T * ptr,size_t n)
ich::allocator::difference_type	allocator/allocator.hpp	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:ich::allocator	typeref:typename:std::ptrdiff_t	access:public
ich::allocator::pointer	allocator/allocator.hpp	/^    typedef T*              pointer;$/;"	t	class:ich::allocator	typeref:typename:T *	access:public
ich::allocator::reference	allocator/allocator.hpp	/^    typedef T&              reference;$/;"	t	class:ich::allocator	typeref:typename:T &	access:public
ich::allocator::size_type	allocator/allocator.hpp	/^    typedef std::size_t     size_type;$/;"	t	class:ich::allocator	typeref:typename:std::size_t	access:public
ich::allocator::value_type	allocator/allocator.hpp	/^    typedef T               value_type;$/;"	t	class:ich::allocator	typeref:typename:T	access:public
ich::bidirectional_iterator_tag	allocator/iterator.hpp	/^struct bidirectional_iterator_tag : public forward_iterator_tag {};$/;"	s	namespace:ich	inherits:forward_iterator_tag
ich::construct	allocator/constructor.hpp	/^inline void construct(T1 *p, const T2 &value) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T1 * p,const T2 & value)
ich::copy	allocator/uninitialized.hpp	/^inline void copy(T *source, T *destination, int n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n)
ich::copy	allocator/uninitialized.hpp	/^void copy(T *source, T *destination, int n, __false_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n,__false_type)
ich::copy	allocator/uninitialized.hpp	/^void copy(T *source, T *destination, int n, __true_type) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * source,T * destination,int n,__true_type)
ich::copy_backward	contains/algorithm.hpp	/^BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last) {$/;"	f	namespace:ich	typeref:typename:BidirIt2	signature:(BidirIt1 first,BidirIt1 last,BidirIt2 d_last)
ich::deque	contains/deque.hpp	/^class deque {$/;"	c	namespace:ich
ich::deque::allocate_node	contains/deque.hpp	/^    pointer allocate_node() { return data_allocator::allocate(sizeof(pointer)); }$/;"	f	class:ich::deque	typeref:typename:pointer	access:protected	signature:()
ich::deque::back	contains/deque.hpp	/^    reference back() {$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:()
ich::deque::begin	contains/deque.hpp	/^    iterator begin() { return start; }$/;"	f	class:ich::deque	typeref:typename:iterator	access:public	signature:()
ich::deque::cback	contains/deque.hpp	/^    const_reference cback() const {$/;"	f	class:ich::deque	typeref:typename:const_reference	access:public	signature:() const
ich::deque::cfront	contains/deque.hpp	/^    const_reference cfront() const { return *start; }$/;"	f	class:ich::deque	typeref:typename:const_reference	access:public	signature:() const
ich::deque::clear	contains/deque.hpp	/^    void clear();$/;"	p	class:ich::deque	typeref:typename:void	access:public	signature:()
ich::deque::clear	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
ich::deque::const_iterator	contains/deque.hpp	/^    typedef __deque_iterator<const T, const T&, const T*, BufSiz> const_iterator;$/;"	t	class:ich::deque	typeref:typename:__deque_iterator<const T,const T &,const T *,BufSiz>	access:public
ich::deque::const_reference	contains/deque.hpp	/^    typedef const T&    const_reference;$/;"	t	class:ich::deque	typeref:typename:const T &	access:public
ich::deque::create_map_and_nodes	contains/deque.hpp	/^    void create_map_and_nodes(size_type num_elements);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type num_elements)
ich::deque::create_map_and_nodes	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type num_elements)
ich::deque::data_allocator	contains/deque.hpp	/^    typedef allocator<value_type>   data_allocator;$/;"	t	class:ich::deque	typeref:typename:allocator<value_type>	access:protected
ich::deque::deallocate_node	contains/deque.hpp	/^    void deallocate_node(pointer x) { data_allocator::deallocate(x, 1); }$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(pointer x)
ich::deque::deque	contains/deque.hpp	/^    deque(int n, const value_type &value) : start(), finish(), map(0), map_size(0) { fill_initia/;"	f	class:ich::deque	access:public	signature:(int n,const value_type & value)
ich::deque::difference_type	contains/deque.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	class:ich::deque	typeref:typename:ptrdiff_t	access:public
ich::deque::empty	contains/deque.hpp	/^    bool empty() const { return finish == start; }$/;"	f	class:ich::deque	typeref:typename:bool	access:public	signature:() const
ich::deque::end	contains/deque.hpp	/^    iterator end() { return finish; }$/;"	f	class:ich::deque	typeref:typename:iterator	access:public	signature:()
ich::deque::erase	contains/deque.hpp	/^    iterator erase(iterator first, iterator last);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator first,iterator last)
ich::deque::erase	contains/deque.hpp	/^    iterator erase(iterator pos);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator pos)
ich::deque::erase	contains/deque.hpp	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator first,iterator last)
ich::deque::erase	contains/deque.hpp	/^deque<T, Alloc, BufSize>::erase(iterator pos) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator pos)
ich::deque::fill_initialize	contains/deque.hpp	/^    void fill_initialize(size_type n, const value_type &value);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type n,const value_type & value)
ich::deque::fill_initialize	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n, const value_type &value) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type n,const value_type & value)
ich::deque::finish	contains/deque.hpp	/^    iterator finish;$/;"	m	class:ich::deque	typeref:typename:iterator	access:protected
ich::deque::front	contains/deque.hpp	/^    reference front() { return *start; }$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:()
ich::deque::initial_map_size	contains/deque.hpp	/^    size_type initial_map_size() { return INITIAL_MAP_SIZE; }$/;"	f	class:ich::deque	typeref:typename:size_type	access:protected	signature:()
ich::deque::insert	contains/deque.hpp	/^    iterator insert(iterator position, const value_type &x);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
ich::deque::insert	contains/deque.hpp	/^deque<T, Alloc, BufSize>::insert(iterator position, const value_type &x) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator position,const value_type & x)
ich::deque::insert_aux	contains/deque.hpp	/^    iterator insert_aux(iterator pos, const value_type &x);$/;"	p	class:ich::deque	typeref:typename:iterator	access:protected	signature:(iterator pos,const value_type & x)
ich::deque::insert_aux	contains/deque.hpp	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type &x) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator pos,const value_type & x)
ich::deque::iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	class:ich::deque	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	access:public
ich::deque::map	contains/deque.hpp	/^    map_pointer map;    \/\/ map是连续空间，每个元素都是指针，指向缓冲区$/;"	m	class:ich::deque	typeref:typename:map_pointer	access:protected
ich::deque::map_allocator	contains/deque.hpp	/^    typedef allocator<pointer>      map_allocator;$/;"	t	class:ich::deque	typeref:typename:allocator<pointer>	access:protected
ich::deque::map_pointer	contains/deque.hpp	/^    typedef pointer*    map_pointer;$/;"	t	class:ich::deque	typeref:typename:pointer *	access:protected
ich::deque::map_size	contains/deque.hpp	/^    size_type map_size; \/\/ map可容纳多少指针$/;"	m	class:ich::deque	typeref:typename:size_type	access:protected
ich::deque::max_size	contains/deque.hpp	/^    size_type max_size() const { return size_type(-1); }$/;"	f	class:ich::deque	typeref:typename:size_type	access:public	signature:() const
ich::deque::operator []	contains/deque.hpp	/^    reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:(size_type n)
ich::deque::pointer	contains/deque.hpp	/^    typedef T*          pointer;$/;"	t	class:ich::deque	typeref:typename:T *	access:public
ich::deque::pop_back	contains/deque.hpp	/^    void pop_back() {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:()
ich::deque::pop_back_aux	contains/deque.hpp	/^    void pop_back_aux();$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:()
ich::deque::pop_back_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::pop_back_aux() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
ich::deque::pop_front	contains/deque.hpp	/^    void pop_front() {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:()
ich::deque::pop_front_aux	contains/deque.hpp	/^    void pop_front_aux();$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:()
ich::deque::pop_front_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
ich::deque::push_back	contains/deque.hpp	/^    void push_back(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:(const value_type & t)
ich::deque::push_back_aux	contains/deque.hpp	/^    void push_back_aux(const value_type &t);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(const value_type & t)
ich::deque::push_back_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(const value_type & t)
ich::deque::push_front	contains/deque.hpp	/^    void push_front(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:(const value_type & t)
ich::deque::push_front_aux	contains/deque.hpp	/^    void push_front_aux(const value_type &t);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(const value_type & t)
ich::deque::push_front_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(const value_type & t)
ich::deque::reallocate_map	contains/deque.hpp	/^    void reallocate_map(size_type nodes_to_add, bool add_at_front);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add,bool add_at_front)
ich::deque::reallocate_map	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add, bool add_at_front) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type nodes_to_add,bool add_at_front)
ich::deque::reference	contains/deque.hpp	/^    typedef T&          reference;$/;"	t	class:ich::deque	typeref:typename:T &	access:public
ich::deque::reserve_map_at_bacK	contains/deque.hpp	/^    void reserve_map_at_bacK(size_type nodes_to_add = 1) {$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add=1)
ich::deque::reserve_map_at_front	contains/deque.hpp	/^    void reserve_map_at_front(size_type nodes_to_add = 1) {$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add=1)
ich::deque::size	contains/deque.hpp	/^    size_type size() const { return finish - start; }   \/\/ iterator::operator-$/;"	f	class:ich::deque	typeref:typename:size_type	access:public	signature:() const
ich::deque::size_type	contains/deque.hpp	/^    typedef size_t      size_type;$/;"	t	class:ich::deque	typeref:typename:size_t	access:public
ich::deque::start	contains/deque.hpp	/^    iterator start;$/;"	m	class:ich::deque	typeref:typename:iterator	access:protected
ich::deque::value_type	contains/deque.hpp	/^    typedef T           value_type;$/;"	t	class:ich::deque	typeref:typename:T	access:public
ich::destory	allocator/constructor.hpp	/^inline void destory(char *, char *) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(char *,char *)
ich::destory	allocator/constructor.hpp	/^inline void destory(wchar_t *, wchar_t *) {}$/;"	f	namespace:ich	typeref:typename:void	signature:(wchar_t *,wchar_t *)
ich::destroy	allocator/constructor.hpp	/^inline void destroy(ForwardIterator first, ForwardIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last)
ich::destroy	allocator/constructor.hpp	/^inline void destroy(T *pointer) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T * pointer)
ich::difference_type	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::difference_type* difference_type(const Iterator&) {$/;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::difference_type *	signature:(const Iterator &)
ich::distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, In/;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last)
ich::distance	allocator/iterator.hpp	/^inline typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, In/;"	f	namespace:ich	typeref:typename:iterator_traits<InputIterator>::difference_type	signature:(InputIterator first,InputIterator last,input_iterator_tag)
ich::distance	allocator/iterator.hpp	/^inline void distance(InputIterator first, InputIterator last, Distance &n) {$/;"	f	namespace:ich	typeref:typename:void	signature:(InputIterator first,InputIterator last,Distance & n)
ich::equal_to	contains/algorithm.hpp	/^struct equal_to$/;"	s	namespace:ich
ich::equal_to::operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs == rhs; }$/;"	f	struct:ich::equal_to	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
ich::find	contains/algorithm.hpp	/^InputIt find(InputIt first, InputIt last, const T& value)$/;"	f	namespace:ich	typeref:typename:InputIt	signature:(InputIt first,InputIt last,const T & value)
ich::forward_iterator_tag	allocator/iterator.hpp	/^struct forward_iterator_tag : public input_iterator_tag {};$/;"	s	namespace:ich	inherits:input_iterator_tag
ich::greater	contains/algorithm.hpp	/^struct greater$/;"	s	namespace:ich
ich::greater::operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs > rhs; }$/;"	f	struct:ich::greater	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
ich::hash	contains/hash_fun.hpp	/^struct hash { };$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<char*>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<char>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<const char*>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<int>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<long long>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<long>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<short>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<signed char>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<unsigned char>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<unsigned int>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<unsigned long long>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<unsigned long>$/;"	s	namespace:ich
ich::hash	contains/hash_fun.hpp	/^struct hash<unsigned short>$/;"	s	namespace:ich
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(char x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(const char *s) const { return __stl_hash_string(s); }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(const char * s) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(int x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(int x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(long long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(long long x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(long x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(short x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(short x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(signed char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(signed char x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned char x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned int x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned long long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned long long x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned long x) const
ich::hash::operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned short x) const
ich::hashtable	contains/hashtable.hpp	/^class hashtable$/;"	c	namespace:ich
ich::hashtable::begin	contains/hashtable.hpp	/^    iterator begin() {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:()
ich::hashtable::bkt_num	contains/hashtable.hpp	/^    size_type bkt_num(const value_type &obj) { return bkt_num_key(get_key(obj)); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const value_type & obj)
ich::hashtable::bkt_num	contains/hashtable.hpp	/^    size_type bkt_num(const value_type &obj, size_t n) { return bkt_num_key(get_key(obj), n); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const value_type & obj,size_t n)
ich::hashtable::bkt_num_key	contains/hashtable.hpp	/^    size_type bkt_num_key(const key_type &key) { return bkt_num_key(key, buckets.size()); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key)
ich::hashtable::bkt_num_key	contains/hashtable.hpp	/^    size_type bkt_num_key(const key_type &key, size_t n) { return ich::hash<key_type>()(key) % n/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key,size_t n)
ich::hashtable::bucket_count	contains/hashtable.hpp	/^    size_type bucket_count() const { return buckets.size(); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
ich::hashtable::buckets	contains/hashtable.hpp	/^    ich::vector<node*, Alloc>       buckets;$/;"	m	class:ich::hashtable	typeref:typename:ich::vector<node *,Alloc>	access:private
ich::hashtable::cbegin	contains/hashtable.hpp	/^    const_iterator cbegin() const {$/;"	f	class:ich::hashtable	typeref:typename:const_iterator	access:public	signature:() const
ich::hashtable::cend	contains/hashtable.hpp	/^    const_iterator cend() { return iterator(0, this); }$/;"	f	class:ich::hashtable	typeref:typename:const_iterator	access:public	signature:()
ich::hashtable::clear	contains/hashtable.hpp	/^    void clear();$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:()
ich::hashtable::clear	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::clear() {$/;"	f	class:ich::hashtable	typeref:typename:void	signature:()
ich::hashtable::const_iterator	contains/hashtable.hpp	/^    typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc> const_i/;"	t	class:ich::hashtable	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::hashtable::const_pointer	contains/hashtable.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:ich::hashtable	typeref:typename:const value_type *	access:public
ich::hashtable::const_reference	contains/hashtable.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:ich::hashtable	typeref:typename:const value_type &	access:public
ich::hashtable::copy_from	contains/hashtable.hpp	/^    void copy_from(const hashtable &ht);$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:(const hashtable & ht)
ich::hashtable::copy_from	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::copy_from(const hashtable &ht)/;"	f	class:ich::hashtable	typeref:typename:void	signature:(const hashtable & ht)
ich::hashtable::count	contains/hashtable.hpp	/^    size_type count(const key_type &key) const {$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(const key_type & key) const
ich::hashtable::delete_node	contains/hashtable.hpp	/^    void delete_node(node *n) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(node * n)
ich::hashtable::difference_type	contains/hashtable.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:ich::hashtable	typeref:typename:ptrdiff_t	access:public
ich::hashtable::elems_in_bucket	contains/hashtable.hpp	/^    size_type elems_in_bucket(size_type bucket) const {$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(size_type bucket) const
ich::hashtable::empty	contains/hashtable.hpp	/^    bool empty() const { return size() == 0; }$/;"	f	class:ich::hashtable	typeref:typename:bool	access:public	signature:() const
ich::hashtable::end	contains/hashtable.hpp	/^    iterator end() { return iterator(0, this); }$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:()
ich::hashtable::equals	contains/hashtable.hpp	/^    key_equal   equals;$/;"	m	class:ich::hashtable	typeref:typename:key_equal	access:private
ich::hashtable::find	contains/hashtable.hpp	/^    iterator find(const key_type &key) {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const key_type & key)
ich::hashtable::get_key	contains/hashtable.hpp	/^    ExtractKey  get_key;$/;"	m	class:ich::hashtable	typeref:typename:ExtractKey	access:private
ich::hashtable::hash	contains/hashtable.hpp	/^    hasher      hash;$/;"	m	class:ich::hashtable	typeref:typename:hasher	access:private
ich::hashtable::hasher	contains/hashtable.hpp	/^    typedef HashFcn hasher;$/;"	t	class:ich::hashtable	typeref:typename:HashFcn	access:public
ich::hashtable::hashtable	contains/hashtable.hpp	/^    hashtable(size_type n, const HashFcn &hf, const EqualKey &eql) : hash(hf), equals(eql), get_/;"	f	class:ich::hashtable	access:public	signature:(size_type n,const HashFcn & hf,const EqualKey & eql)
ich::hashtable::initialize_buckets	contains/hashtable.hpp	/^    void initialize_buckets(size_type n) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(size_type n)
ich::hashtable::insert_equal	contains/hashtable.hpp	/^    iterator insert_equal(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const value_type & obj)
ich::hashtable::insert_equal_noresize	contains/hashtable.hpp	/^    iterator insert_equal_noresize(const value_type &obj);$/;"	p	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const value_type & obj)
ich::hashtable::insert_equal_noresize	contains/hashtable.hpp	/^hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::insert_equal_noresize(const value_t/;"	f	class:ich::hashtable	typeref:typename:hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>::iterator	signature:(const value_type & obj)
ich::hashtable::insert_unique	contains/hashtable.hpp	/^    pair<iterator, bool> insert_unique(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & obj)
ich::hashtable::insert_unique_noresize	contains/hashtable.hpp	/^    pair<iterator, bool> insert_unique_noresize(const value_type &obj);$/;"	p	class:ich::hashtable	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & obj)
ich::hashtable::insert_unique_noresize	contains/hashtable.hpp	/^hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::insert_unique_noresize(const value_/;"	f	class:ich::hashtable	typeref:typename:pair<typename hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>::iterator,bool>	signature:(const value_type & obj)
ich::hashtable::iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc> iterator;$/;"	t	class:ich::hashtable	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
ich::hashtable::key_equal	contains/hashtable.hpp	/^    typedef EqualKey key_equal;$/;"	t	class:ich::hashtable	typeref:typename:EqualKey	access:public
ich::hashtable::key_type	contains/hashtable.hpp	/^    typedef Key key_type;$/;"	t	class:ich::hashtable	typeref:typename:Key	access:public
ich::hashtable::max_bucket_count	contains/hashtable.hpp	/^    size_type max_bucket_count() const { return __stl_prime_list[__stl_num_primes - 1]; }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
ich::hashtable::new_node	contains/hashtable.hpp	/^    node* new_node(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:node *	access:public	signature:(const value_type & obj)
ich::hashtable::next_size	contains/hashtable.hpp	/^    size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(size_type n) const
ich::hashtable::node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	class:ich::hashtable	typeref:typename:__hashtable_node<Value>	access:private
ich::hashtable::node_allocator	contains/hashtable.hpp	/^    typedef allocator<node>         node_allocator;$/;"	t	class:ich::hashtable	typeref:typename:allocator<node>	access:private
ich::hashtable::num_elements	contains/hashtable.hpp	/^    size_type                       num_elements;$/;"	m	class:ich::hashtable	typeref:typename:size_type	access:private
ich::hashtable::pointer	contains/hashtable.hpp	/^    typedef value_type* pointer;$/;"	t	class:ich::hashtable	typeref:typename:value_type *	access:public
ich::hashtable::reference	contains/hashtable.hpp	/^    typedef value_type& reference;$/;"	t	class:ich::hashtable	typeref:typename:value_type &	access:public
ich::hashtable::resize	contains/hashtable.hpp	/^    void resize(size_type num_elements_hint);$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:(size_type num_elements_hint)
ich::hashtable::resize	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::resize(size_type num_elements_/;"	f	class:ich::hashtable	typeref:typename:void	signature:(size_type num_elements_hint)
ich::hashtable::size	contains/hashtable.hpp	/^    size_type size() const { return num_elements; }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
ich::hashtable::size_type	contains/hashtable.hpp	/^    typedef size_t size_type;$/;"	t	class:ich::hashtable	typeref:typename:size_t	access:public
ich::hashtable::swap	contains/hashtable.hpp	/^    void swap(hashtable &ht) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(hashtable & ht)
ich::hashtable::value_type	contains/hashtable.hpp	/^    typedef Value value_type;$/;"	t	class:ich::hashtable	typeref:typename:Value	access:public
ich::hashtable::~hashtable	contains/hashtable.hpp	/^    ~hashtable() { clear(); }$/;"	f	class:ich::hashtable	access:public	signature:()
ich::icopy	contains/algorithm.hpp	/^OutputIt icopy(InputIt first, InputIt last, OutputIt d_first) {$/;"	f	namespace:ich	typeref:typename:OutputIt	signature:(InputIt first,InputIt last,OutputIt d_first)
ich::identity	contains/algorithm.hpp	/^struct identity \/*: public unary_function<T, T> *\/$/;"	s	namespace:ich
ich::identity::operator ()	contains/algorithm.hpp	/^    const T& operator()(const T &x) const { return x; }$/;"	f	struct:ich::identity	typeref:typename:const T &	access:public	signature:(const T & x) const
ich::identity::operator ()	contains/algorithm.hpp	/^    const T&& operator()(const T &&x) const { return x; }$/;"	f	struct:ich::identity	typeref:typename:const T &&	access:public	signature:(const T && x) const
ich::input_iterator_tag	allocator/iterator.hpp	/^struct input_iterator_tag {};$/;"	s	namespace:ich
ich::iterator	allocator/iterator.hpp	/^struct iterator {$/;"	s	namespace:ich
ich::iterator::difference_type	allocator/iterator.hpp	/^    typedef Distance    difference_type;$/;"	t	struct:ich::iterator	typeref:typename:Distance	access:public
ich::iterator::iterator_category	allocator/iterator.hpp	/^    typedef Category    iterator_category;$/;"	t	struct:ich::iterator	typeref:typename:Category	access:public
ich::iterator::pointer	allocator/iterator.hpp	/^    typedef Pointer     pointer;$/;"	t	struct:ich::iterator	typeref:typename:Pointer	access:public
ich::iterator::reference	allocator/iterator.hpp	/^    typedef Reference   reference;$/;"	t	struct:ich::iterator	typeref:typename:Reference	access:public
ich::iterator::value_type	allocator/iterator.hpp	/^    typedef T           value_type;$/;"	t	struct:ich::iterator	typeref:typename:T	access:public
ich::iterator_category	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::iterator_category iterator_category(const Iterator&) /;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::iterator_category	signature:(const Iterator &)
ich::iterator_traits	allocator/iterator.hpp	/^struct iterator_traits {$/;"	s	namespace:ich
ich::iterator_traits	allocator/iterator.hpp	/^struct iterator_traits<T*> {$/;"	s	namespace:ich
ich::iterator_traits	allocator/iterator.hpp	/^struct iterator_traits<const T*> {$/;"	s	namespace:ich
ich::iterator_traits::difference_type	allocator/iterator.hpp	/^    typedef ptrdiff_t                   difference_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:ptrdiff_t	access:public
ich::iterator_traits::difference_type	allocator/iterator.hpp	/^    typedef typename Iterator::difference_type      difference_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::difference_type	access:public
ich::iterator_traits::iterator_category	allocator/iterator.hpp	/^    typedef random_access_iterator_tag  iterator_category;$/;"	t	struct:ich::iterator_traits	typeref:typename:random_access_iterator_tag	access:public
ich::iterator_traits::iterator_category	allocator/iterator.hpp	/^    typedef typename Iterator::iterator_category    iterator_category;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::iterator_category	access:public
ich::iterator_traits::pointer	allocator/iterator.hpp	/^    typedef T*                          pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:T *	access:public
ich::iterator_traits::pointer	allocator/iterator.hpp	/^    typedef const T*                    pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:const T *	access:public
ich::iterator_traits::pointer	allocator/iterator.hpp	/^    typedef typename Iterator::pointer              pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::pointer	access:public
ich::iterator_traits::reference	allocator/iterator.hpp	/^    typedef T&                          reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:T &	access:public
ich::iterator_traits::reference	allocator/iterator.hpp	/^    typedef const T&                    reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:const T &	access:public
ich::iterator_traits::reference	allocator/iterator.hpp	/^    typedef typename Iterator::reference            reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::reference	access:public
ich::iterator_traits::value_type	allocator/iterator.hpp	/^    typedef T                           value_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:T	access:public
ich::iterator_traits::value_type	allocator/iterator.hpp	/^    typedef typename Iterator::value_type           value_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::value_type	access:public
ich::less	contains/algorithm.hpp	/^struct less$/;"	s	namespace:ich
ich::less::operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs < rhs; }$/;"	f	struct:ich::less	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
ich::list	contains/list_temp.hpp	/^class list {$/;"	c	namespace:ich
ich::list::back	contains/list_temp.hpp	/^    reference back() { return *(--end()); }$/;"	f	class:ich::list	typeref:typename:reference	access:public	signature:()
ich::list::begin	contains/list_temp.hpp	/^    iterator begin() { return (link_type)((*node).next); }$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:()
ich::list::clear	contains/list_temp.hpp	/^    void clear() {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
ich::list::const_iterator	contains/list_temp.hpp	/^    typedef __list_iterator<const T> const_iterator;$/;"	t	class:ich::list	typeref:typename:__list_iterator<const T>	access:public
ich::list::create_node	contains/list_temp.hpp	/^    link_type create_node(const T &x) {$/;"	f	class:ich::list	typeref:typename:link_type	access:protected	signature:(const T & x)
ich::list::destroy_node	contains/list_temp.hpp	/^    void destroy_node(link_type p) {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(link_type p)
ich::list::empty	contains/list_temp.hpp	/^    bool empty() const { return node->next == node; }$/;"	f	class:ich::list	typeref:typename:bool	access:public	signature:() const
ich::list::empty_initialize	contains/list_temp.hpp	/^    void empty_initialize() {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:()
ich::list::end	contains/list_temp.hpp	/^    iterator end() { return node; }$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:()
ich::list::erase	contains/list_temp.hpp	/^    iterator erase(iterator position) {$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:(iterator position)
ich::list::front	contains/list_temp.hpp	/^    reference front() { return *begin(); }$/;"	f	class:ich::list	typeref:typename:reference	access:public	signature:()
ich::list::get_node	contains/list_temp.hpp	/^    link_type get_node() { return (link_type)list_node_allocator::allocate(); }$/;"	f	class:ich::list	typeref:typename:link_type	access:protected	signature:()
ich::list::insert	contains/list_temp.hpp	/^    iterator insert(iterator position, const T &x) {$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:(iterator position,const T & x)
ich::list::iterator	contains/list_temp.hpp	/^    typedef __list_iterator<T>       iterator;$/;"	t	class:ich::list	typeref:typename:__list_iterator<T>	access:public
ich::list::link_type	contains/list_temp.hpp	/^    typedef __list_node<T>*          link_type;$/;"	t	class:ich::list	typeref:typename:__list_node<T> *	access:public
ich::list::list	contains/list_temp.hpp	/^    list() { empty_initialize(); }$/;"	f	class:ich::list	access:public	signature:()
ich::list::list_node	contains/list_temp.hpp	/^    typedef __list_node<T>          list_node;$/;"	t	class:ich::list	typeref:typename:__list_node<T>	access:protected
ich::list::list_node_allocator	contains/list_temp.hpp	/^    typedef Alloc                   list_node_allocator;$/;"	t	class:ich::list	typeref:typename:Alloc	access:protected
ich::list::node	contains/list_temp.hpp	/^    link_type node; \/\/ 只需要一个指针，就能实现环状双向链表$/;"	m	class:ich::list	typeref:typename:link_type	access:protected
ich::list::pop_back	contains/list_temp.hpp	/^    void pop_back() { iterator tmp = end(); erase(--tmp); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
ich::list::pop_front	contains/list_temp.hpp	/^    void pop_front() { erase(begin()); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
ich::list::push_back	contains/list_temp.hpp	/^    void push_back(const T &x) { insert(end(), x); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & x)
ich::list::push_front	contains/list_temp.hpp	/^    void push_front(const T &x) { insert(begin(), x); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & x)
ich::list::put_node	contains/list_temp.hpp	/^    void put_node(link_type p) { list_node_allocator::deallocate((T*)p); }$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(link_type p)
ich::list::reference	contains/list_temp.hpp	/^    typedef T&                       reference;$/;"	t	class:ich::list	typeref:typename:T &	access:public
ich::list::remove	contains/list_temp.hpp	/^    void remove(const T &value) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & value)
ich::list::size	contains/list_temp.hpp	/^    size_type size() {$/;"	f	class:ich::list	typeref:typename:size_type	access:public	signature:()
ich::list::size_type	contains/list_temp.hpp	/^    typedef size_t                   size_type;$/;"	t	class:ich::list	typeref:typename:size_t	access:public
ich::list::splice	contains/list_temp.hpp	/^    void splice(iterator position, list &, iterator i) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(iterator position,list &,iterator i)
ich::list::splice	contains/list_temp.hpp	/^    void splice(iterator position, list &x) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(iterator position,list & x)
ich::list::transfer	contains/list_temp.hpp	/^    void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(iterator position,iterator first,iterator last)
ich::list::unique	contains/list_temp.hpp	/^    void unique() {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
ich::list::value_type	contains/list_temp.hpp	/^    typedef T                        value_type;$/;"	t	class:ich::list	typeref:typename:T	access:public
ich::lower_bound	contains/algorithm.hpp	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T &value) /;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value)
ich::lower_bound	contains/algorithm.hpp	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T &value, /;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Compare comp)
ich::make_heap	contains/algorithm.hpp	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
ich::make_heap	contains/algorithm.hpp	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
ich::make_pair	contains/pair.hpp	/^inline pair<T1, T2> make_pair(const T1 &_x, const T2 &_y) {$/;"	f	namespace:ich	typeref:typename:pair<T1,T2>	signature:(const T1 & _x,const T2 & _y)
ich::malloc_alloc	allocator/alloc.hpp	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t	namespace:ich	typeref:typename:__malloc_alloc_template<0>
ich::map	contains/map.hpp	/^class map$/;"	c	namespace:ich
ich::map::begin	contains/map.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:()
ich::map::cbegin	contains/map.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:() const
ich::map::cend	contains/map.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:() const
ich::map::clear	contains/map.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:()
ich::map::const_iterator	contains/map.hpp	/^    typedef typename rep_type::const_iterator           const_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::const_iterator	access:public
ich::map::const_pointer	contains/map.hpp	/^    typedef typename rep_type::const_pointer            const_pointer;$/;"	t	class:ich::map	typeref:typename:rep_type::const_pointer	access:public
ich::map::const_reference	contains/map.hpp	/^    typedef typename rep_type::const_reference          const_reference;$/;"	t	class:ich::map	typeref:typename:rep_type::const_reference	access:public
ich::map::const_reverse_iterator	contains/map.hpp	/^    typedef typename rep_type::const_reverse_iterator   const_reverse_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::const_reverse_iterator	access:public
ich::map::count	contains/map.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:(const key_type & x) const
ich::map::data_type	contains/map.hpp	/^    typedef T                       data_type;$/;"	t	class:ich::map	typeref:typename:T	access:public
ich::map::difference_type	contains/map.hpp	/^    typedef typename rep_type::difference_type          difference_type;$/;"	t	class:ich::map	typeref:typename:rep_type::difference_type	access:public
ich::map::empty	contains/map.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::map	typeref:typename:bool	access:public	signature:() const
ich::map::end	contains/map.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:()
ich::map::equal_range	contains/map.hpp	/^    ich::pair<iterator, iterator> equal_range(const key_type &x) { return t.equal_range(x); }$/;"	f	class:ich::map	typeref:typename:ich::pair<iterator,iterator>	access:public	signature:(const key_type & x)
ich::map::equal_range	contains/map.hpp	/^    ich::pari<const_iterator, const_iterator> equal_range(const key_type &x) const { return t.eq/;"	f	class:ich::map	typeref:typename:ich::pari<const_iterator,const_iterator>	access:public	signature:(const key_type & x) const
ich::map::erase	contains/map.hpp	/^    size_type erase(const key_type &x) { return t.erase(x); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:(const key_type & x)
ich::map::erase	contains/map.hpp	/^    void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(iterator first,iterator last)
ich::map::erase	contains/map.hpp	/^    void erase(iterator position) { t.erase(position); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(iterator position)
ich::map::find	contains/map.hpp	/^    const_iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::map::find	contains/map.hpp	/^    iterator find(const key_type &x) { return t.find(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::map::insert	contains/map.hpp	/^    iterator insert(iterator position, const value_type &x) { return t.insert_unique(position, x/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
ich::map::insert	contains/map.hpp	/^    std::pair<iterator, bool> insert(const value_type &x) { return t.insert_unique(x); }$/;"	f	class:ich::map	typeref:typename:std::pair<iterator,bool>	access:public	signature:(const value_type & x)
ich::map::insert	contains/map.hpp	/^    void insert(InputIterator first, InputIterator last) { t.insert_unique(first, last); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
ich::map::iterator	contains/map.hpp	/^    typedef typename rep_type::iterator                 iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::iterator	access:public
ich::map::key_comp	contains/map.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::map	typeref:typename:key_compare	access:public	signature:() const
ich::map::key_compare	contains/map.hpp	/^    typedef Compare                 key_compare;$/;"	t	class:ich::map	typeref:typename:Compare	access:public
ich::map::key_type	contains/map.hpp	/^    typedef Key                     key_type;$/;"	t	class:ich::map	typeref:typename:Key	access:public
ich::map::lower_bound	contains/map.hpp	/^    const_iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::map::lower_bound	contains/map.hpp	/^    iterator lower_bound(const key_type &x) { return t.lower_bound(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::map::map	contains/map.hpp	/^    explicit map(const Compare &comp) : t(comp) {}$/;"	f	class:ich::map	access:public	signature:(const Compare & comp)
ich::map::map	contains/map.hpp	/^    map() : t(Compare()) {}$/;"	f	class:ich::map	access:public	signature:()
ich::map::map	contains/map.hpp	/^    map(InputIterator first, InputIterator last) : t(Compare()) { t.insert_unique(first, last); /;"	f	class:ich::map	access:public	signature:(InputIterator first,InputIterator last)
ich::map::map	contains/map.hpp	/^    map(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_uniqu/;"	f	class:ich::map	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
ich::map::map	contains/map.hpp	/^    map(const map<Key, T, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::map	access:public	signature:(const map<Key,T,Compare,Alloc> & x)
ich::map::mapped_type	contains/map.hpp	/^    typedef T                       mapped_type;$/;"	t	class:ich::map	typeref:typename:T	access:public
ich::map::max_size	contains/map.hpp	/^    size_type max_size() const { return t.size(); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:() const
ich::map::operator []	contains/map.hpp	/^    t& operator[](const key_type &k) { return (*((insert(value_type(k, T()))).first)).second; } /;"	f	class:ich::map	typeref:typename:t &	access:public	signature:(const key_type & k)
ich::map::pointer	contains/map.hpp	/^    typedef typename rep_type::pointer                  pointer;$/;"	t	class:ich::map	typeref:typename:rep_type::pointer	access:public
ich::map::rbegin	contains/map.hpp	/^    const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:ich::map	typeref:typename:const_reverse_iterator	access:public	signature:() const
ich::map::rbegin	contains/map.hpp	/^    reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:ich::map	typeref:typename:reverse_iterator	access:public	signature:()
ich::map::reference	contains/map.hpp	/^    typedef typename rep_type::reference                reference;$/;"	t	class:ich::map	typeref:typename:rep_type::reference	access:public
ich::map::rend	contains/map.hpp	/^    const_reverse_iterator rend() const { return t.end(); }$/;"	f	class:ich::map	typeref:typename:const_reverse_iterator	access:public	signature:() const
ich::map::rend	contains/map.hpp	/^    reverse_iterator rend() { return t.rend(); }$/;"	f	class:ich::map	typeref:typename:reverse_iterator	access:public	signature:()
ich::map::rep_type	contains/map.hpp	/^    typedef rb_tree<key_type, value_type, select1st<value_type>, key_comp, Alloc> rep_type;$/;"	t	class:ich::map	typeref:typename:rb_tree<key_type,value_type,select1st<value_type>,key_comp,Alloc>	access:private
ich::map::reverse_iterator	contains/map.hpp	/^    typedef typename rep_type::reverse_iterator         reverse_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::reverse_iterator	access:public
ich::map::size	contains/map.hpp	/^    size_type size() const { return t.empty(); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:() const
ich::map::size_type	contains/map.hpp	/^    typedef typename rep_type::size_type                size_type;$/;"	t	class:ich::map	typeref:typename:rep_type::size_type	access:public
ich::map::swap	contains/map.hpp	/^    void swap(map<Key, T, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(map<Key,T,Compare,Alloc> & x)
ich::map::t	contains/map.hpp	/^    rep_type t;$/;"	m	class:ich::map	typeref:typename:rep_type	access:private
ich::map::upper_bound	contains/map.hpp	/^    const_iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::map::upper_bound	contains/map.hpp	/^    iterator upper_bound(const key_type &x) { return t.upper_bound(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::map::value_comp	contains/map.hpp	/^    value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:ich::map	typeref:typename:value_compare	access:public	signature:() const
ich::map::value_compare	contains/map.hpp	/^    class value_compare : public std::binary_function<value_type, value_type, bool> {$/;"	c	class:ich::map	inherits:std::binary_function<value_type,value_type,bool>	access:public
ich::map::value_compare::comp	contains/map.hpp	/^        Compare comp;$/;"	m	class:ich::map::value_compare	typeref:typename:Compare	access:protected
ich::map::value_compare::operator () 	contains/map.hpp	/^        bool operator() (const value_type &x, const value_type &y) const { return comp(x.first, /;"	f	class:ich::map::value_compare	typeref:typename:bool	access:public	signature:(const value_type & x,const value_type & y) const
ich::map::value_compare::value_compare	contains/map.hpp	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:ich::map::value_compare	access:protected	signature:(Compare c)
ich::map::value_type	contains/map.hpp	/^    typedef ich::pair<const Key, T> value_type;$/;"	t	class:ich::map	typeref:typename:ich::pair<const Key,T>	access:public
ich::max	contains/algorithm.hpp	/^T max(const T &left, const T &right) {$/;"	f	namespace:ich	typeref:typename:T	signature:(const T & left,const T & right)
ich::multimap	contains/multimap.hpp	/^class multimap$/;"	c	namespace:ich
ich::multimap::begin	contains/multimap.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:()
ich::multimap::cbegin	contains/multimap.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:() const
ich::multimap::cend	contains/multimap.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:() const
ich::multimap::clear	contains/multimap.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:()
ich::multimap::const_iterator	contains/multimap.hpp	/^    typedef typename rep_type::const_iterator           const_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_iterator	access:public
ich::multimap::const_pointer	contains/multimap.hpp	/^    typedef typename rep_type::const_pointer            const_pointer;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_pointer	access:public
ich::multimap::const_reference	contains/multimap.hpp	/^    typedef typename rep_type::const_reference          const_reference;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_reference	access:public
ich::multimap::const_reverse_iterator	contains/multimap.hpp	/^    typedef typename rep_type::const_reverse_iterator   const_reverse_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::const_reverse_iterator	access:public
ich::multimap::count	contains/multimap.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:(const key_type & x) const
ich::multimap::data_type	contains/multimap.hpp	/^    typedef T                       data_type;$/;"	t	class:ich::multimap	typeref:typename:T	access:public
ich::multimap::difference_type	contains/multimap.hpp	/^    typedef typename rep_type::difference_type          difference_type;$/;"	t	class:ich::multimap	typeref:typename:rep_type::difference_type	access:public
ich::multimap::empty	contains/multimap.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::multimap	typeref:typename:bool	access:public	signature:() const
ich::multimap::end	contains/multimap.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:()
ich::multimap::equal_range	contains/multimap.hpp	/^    ich::pair<iterator, iterator> equal_range(const key_type &x) { return t.equal_range(x); }$/;"	f	class:ich::multimap	typeref:typename:ich::pair<iterator,iterator>	access:public	signature:(const key_type & x)
ich::multimap::equal_range	contains/multimap.hpp	/^    ich::pari<const_iterator, const_iterator> equal_range(const key_type &x) const { return t.eq/;"	f	class:ich::multimap	typeref:typename:ich::pari<const_iterator,const_iterator>	access:public	signature:(const key_type & x) const
ich::multimap::erase	contains/multimap.hpp	/^    size_type erase(const key_type &x) { return t.erase(x); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:(const key_type & x)
ich::multimap::erase	contains/multimap.hpp	/^    void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(iterator first,iterator last)
ich::multimap::erase	contains/multimap.hpp	/^    void erase(iterator position) { t.erase(position); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(iterator position)
ich::multimap::find	contains/multimap.hpp	/^    const_iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::multimap::find	contains/multimap.hpp	/^    iterator find(const key_type &x) { return t.find(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::multimap::insert	contains/multimap.hpp	/^    iterator insert(iterator position, const value_type &x) { return t.insert_equal(position, x)/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
ich::multimap::insert	contains/multimap.hpp	/^    std::pair<iterator, bool> insert(const value_type &x) { return t.insert_equal(x); }$/;"	f	class:ich::multimap	typeref:typename:std::pair<iterator,bool>	access:public	signature:(const value_type & x)
ich::multimap::insert	contains/multimap.hpp	/^    void insert(InputIterator first, InputIterator last) { t.insert_equal(first, last); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
ich::multimap::iterator	contains/multimap.hpp	/^    typedef typename rep_type::iterator                 iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::iterator	access:public
ich::multimap::key_comp	contains/multimap.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::multimap	typeref:typename:key_compare	access:public	signature:() const
ich::multimap::key_compare	contains/multimap.hpp	/^    typedef Compare                 key_compare;$/;"	t	class:ich::multimap	typeref:typename:Compare	access:public
ich::multimap::key_type	contains/multimap.hpp	/^    typedef Key                     key_type;$/;"	t	class:ich::multimap	typeref:typename:Key	access:public
ich::multimap::lower_bound	contains/multimap.hpp	/^    const_iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::multimap::lower_bound	contains/multimap.hpp	/^    iterator lower_bound(const key_type &x) { return t.lower_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::multimap::max_size	contains/multimap.hpp	/^    size_type max_size() const { return t.size(); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:() const
ich::multimap::multimap	contains/multimap.hpp	/^    explicit multimap(const Compare &comp) : t(comp) {}$/;"	f	class:ich::multimap	access:public	signature:(const Compare & comp)
ich::multimap::multimap	contains/multimap.hpp	/^    multimap() : t(Compare()) {}$/;"	f	class:ich::multimap	access:public	signature:()
ich::multimap::multimap	contains/multimap.hpp	/^    multimap(InputIterator first, InputIterator last) : t(Compare()) { t.insert_equal(first, las/;"	f	class:ich::multimap	access:public	signature:(InputIterator first,InputIterator last)
ich::multimap::multimap	contains/multimap.hpp	/^    multimap(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_/;"	f	class:ich::multimap	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
ich::multimap::multimap	contains/multimap.hpp	/^    multimap(const multimap<Key, T, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::multimap	access:public	signature:(const multimap<Key,T,Compare,Alloc> & x)
ich::multimap::multimapped_type	contains/multimap.hpp	/^    typedef T                       multimapped_type;$/;"	t	class:ich::multimap	typeref:typename:T	access:public
ich::multimap::operator []	contains/multimap.hpp	/^    t& operator[](const key_type &k) { return (*((insert(value_type(k, T()))).first)).second; } /;"	f	class:ich::multimap	typeref:typename:t &	access:public	signature:(const key_type & k)
ich::multimap::pointer	contains/multimap.hpp	/^    typedef typename rep_type::pointer                  pointer;$/;"	t	class:ich::multimap	typeref:typename:rep_type::pointer	access:public
ich::multimap::rbegin	contains/multimap.hpp	/^    const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:ich::multimap	typeref:typename:const_reverse_iterator	access:public	signature:() const
ich::multimap::rbegin	contains/multimap.hpp	/^    reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:ich::multimap	typeref:typename:reverse_iterator	access:public	signature:()
ich::multimap::reference	contains/multimap.hpp	/^    typedef typename rep_type::reference                reference;$/;"	t	class:ich::multimap	typeref:typename:rep_type::reference	access:public
ich::multimap::rend	contains/multimap.hpp	/^    const_reverse_iterator rend() const { return t.end(); }$/;"	f	class:ich::multimap	typeref:typename:const_reverse_iterator	access:public	signature:() const
ich::multimap::rend	contains/multimap.hpp	/^    reverse_iterator rend() { return t.rend(); }$/;"	f	class:ich::multimap	typeref:typename:reverse_iterator	access:public	signature:()
ich::multimap::rep_type	contains/multimap.hpp	/^    typedef rb_tree<key_type, value_type, select1st<value_type>, key_comp, Alloc> rep_type;$/;"	t	class:ich::multimap	typeref:typename:rb_tree<key_type,value_type,select1st<value_type>,key_comp,Alloc>	access:private
ich::multimap::reverse_iterator	contains/multimap.hpp	/^    typedef typename rep_type::reverse_iterator         reverse_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::reverse_iterator	access:public
ich::multimap::size	contains/multimap.hpp	/^    size_type size() const { return t.empty(); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:() const
ich::multimap::size_type	contains/multimap.hpp	/^    typedef typename rep_type::size_type                size_type;$/;"	t	class:ich::multimap	typeref:typename:rep_type::size_type	access:public
ich::multimap::swap	contains/multimap.hpp	/^    void swap(multimap<Key, T, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(multimap<Key,T,Compare,Alloc> & x)
ich::multimap::t	contains/multimap.hpp	/^    rep_type t;$/;"	m	class:ich::multimap	typeref:typename:rep_type	access:private
ich::multimap::upper_bound	contains/multimap.hpp	/^    const_iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
ich::multimap::upper_bound	contains/multimap.hpp	/^    iterator upper_bound(const key_type &x) { return t.upper_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
ich::multimap::value_comp	contains/multimap.hpp	/^    value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:ich::multimap	typeref:typename:value_compare	access:public	signature:() const
ich::multimap::value_compare	contains/multimap.hpp	/^    class value_compare : public std::binary_function<value_type, value_type, bool> {$/;"	c	class:ich::multimap	inherits:std::binary_function<value_type,value_type,bool>	access:public
ich::multimap::value_compare::comp	contains/multimap.hpp	/^        Compare comp;$/;"	m	class:ich::multimap::value_compare	typeref:typename:Compare	access:protected
ich::multimap::value_compare::operator () 	contains/multimap.hpp	/^        bool operator() (const value_type &x, const value_type &y) const { return comp(x.first, /;"	f	class:ich::multimap::value_compare	typeref:typename:bool	access:public	signature:(const value_type & x,const value_type & y) const
ich::multimap::value_compare::value_compare	contains/multimap.hpp	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:ich::multimap::value_compare	access:protected	signature:(Compare c)
ich::multimap::value_type	contains/multimap.hpp	/^    typedef ich::pair<const Key, T> value_type;$/;"	t	class:ich::multimap	typeref:typename:ich::pair<const Key,T>	access:public
ich::multiset	contains/multiset.hpp	/^class multiset {$/;"	c	namespace:ich
ich::multiset::begin	contains/multiset.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:()
ich::multiset::cbegin	contains/multiset.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::multiset	typeref:typename:const_iterator	access:public	signature:() const
ich::multiset::cend	contains/multiset.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::multiset	typeref:typename:const_iterator	access:public	signature:() const
ich::multiset::clear	contains/multiset.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:()
ich::multiset::const_iterator	contains/multiset.hpp	/^    typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_iterator	access:public
ich::multiset::const_pointer	contains/multiset.hpp	/^    typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_pointer	access:public
ich::multiset::const_reference	contains/multiset.hpp	/^    typedef typename rep_type::const_reference const_reference;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_reference	access:public
ich::multiset::count	contains/multiset.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:(const key_type & x) const
ich::multiset::difference_type	contains/multiset.hpp	/^    typedef typename rep_type::difference_type difference_type;$/;"	t	class:ich::multiset	typeref:typename:rep_type::difference_type	access:public
ich::multiset::empty	contains/multiset.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::multiset	typeref:typename:bool	access:public	signature:() const
ich::multiset::end	contains/multiset.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:()
ich::multiset::equal_range	contains/multiset.hpp	/^    pair<iterator, iterator> equal_range(const key_type &x) const { return t.equal_range(x); }$/;"	f	class:ich::multiset	typeref:typename:pair<iterator,iterator>	access:public	signature:(const key_type & x) const
ich::multiset::erase	contains/multiset.hpp	/^    size_type erase(const key_type &x) {$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:(const key_type & x)
ich::multiset::erase	contains/multiset.hpp	/^    void erase(iterator first, iterator last) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(iterator first,iterator last)
ich::multiset::erase	contains/multiset.hpp	/^    void erase(iterator position) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(iterator position)
ich::multiset::find	contains/multiset.hpp	/^    iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::multiset::insert	contains/multiset.hpp	/^    iterator insert(const value_type &x) {$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const value_type & x)
ich::multiset::insert	contains/multiset.hpp	/^    iterator insert(iterator position, const value_type &x) {$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
ich::multiset::insert	contains/multiset.hpp	/^    void insert(InputIterator first, InputIterator last) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
ich::multiset::iterator	contains/multiset.hpp	/^    typedef typename rep_type::const_iterator iterator;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_iterator	access:public
ich::multiset::key_comp	contains/multiset.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::multiset	typeref:typename:key_compare	access:public	signature:() const
ich::multiset::key_compare	contains/multiset.hpp	/^    typedef Compare key_compare;$/;"	t	class:ich::multiset	typeref:typename:Compare	access:public
ich::multiset::key_type	contains/multiset.hpp	/^    typedef Key key_type;$/;"	t	class:ich::multiset	typeref:typename:Key	access:public
ich::multiset::lower_bound	contains/multiset.hpp	/^    iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::multiset::max_size	contains/multiset.hpp	/^    size_type max_size() const { return t.max_size(); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:() const
ich::multiset::multiset	contains/multiset.hpp	/^    explicit multiset(const Compare &comp) : t(comp) {}$/;"	f	class:ich::multiset	access:public	signature:(const Compare & comp)
ich::multiset::multiset	contains/multiset.hpp	/^    multiset() : t(Compare()) {}$/;"	f	class:ich::multiset	access:public	signature:()
ich::multiset::multiset	contains/multiset.hpp	/^    multiset(InputIterator first, InputIterator last) : t(Compare()) { t.insert_equal(first, las/;"	f	class:ich::multiset	access:public	signature:(InputIterator first,InputIterator last)
ich::multiset::multiset	contains/multiset.hpp	/^    multiset(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_/;"	f	class:ich::multiset	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
ich::multiset::multiset	contains/multiset.hpp	/^    multiset(const multiset<Key, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::multiset	access:public	signature:(const multiset<Key,Compare,Alloc> & x)
ich::multiset::operator =	contains/multiset.hpp	/^    multiset<Key, Compare, Alloc>& operator=(const multiset<Key, Compare, Alloc> &x) { t = x.t; /;"	f	class:ich::multiset	typeref:typename:multiset<Key,Compare,Alloc> &	access:public	signature:(const multiset<Key,Compare,Alloc> & x)
ich::multiset::pair_iterator_bool	contains/multiset.hpp	/^    typedef pair<iterator, bool> pair_iterator_bool;$/;"	t	class:ich::multiset	typeref:typename:pair<iterator,bool>	access:public
ich::multiset::pointer	contains/multiset.hpp	/^    typedef typename rep_type::const_pointer pointer;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_pointer	access:public
ich::multiset::reference	contains/multiset.hpp	/^    typedef typename rep_type::const_reference reference;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_reference	access:public
ich::multiset::rep_type	contains/multiset.hpp	/^    typedef rb_tree<key_type, value_type, identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:ich::multiset	typeref:typename:rb_tree<key_type,value_type,identity<value_type>,key_compare,Alloc>	access:private
ich::multiset::size	contains/multiset.hpp	/^    size_type size() const { return t.size(); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:() const
ich::multiset::size_type	contains/multiset.hpp	/^    typedef typename rep_type::size_type size_type;$/;"	t	class:ich::multiset	typeref:typename:rep_type::size_type	access:public
ich::multiset::swap	contains/multiset.hpp	/^    void swap(multiset<Key, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(multiset<Key,Compare,Alloc> & x)
ich::multiset::t	contains/multiset.hpp	/^    rep_type t; \/\/ 用红黑树来表现multiset$/;"	m	class:ich::multiset	typeref:typename:rep_type	access:private
ich::multiset::upper_bound	contains/multiset.hpp	/^    iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::multiset::value_comp	contains/multiset.hpp	/^    value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:ich::multiset	typeref:typename:value_compare	access:public	signature:() const
ich::multiset::value_compare	contains/multiset.hpp	/^    typedef Compare value_compare;$/;"	t	class:ich::multiset	typeref:typename:Compare	access:public
ich::multiset::value_type	contains/multiset.hpp	/^    typedef Key value_type;$/;"	t	class:ich::multiset	typeref:typename:Key	access:public
ich::operator !=	contains/pair.hpp	/^inline bool operator!=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::operator <	contains/multiset.hpp	/^inline bool operator<(const multiset<Key, Compare, Alloc> &x, const multiset<Key, Compare, Alloc/;"	f	namespace:ich	typeref:typename:bool	signature:(const multiset<Key,Compare,Alloc> & x,const multiset<Key,Compare,Alloc> & y)
ich::operator <	contains/pair.hpp	/^inline bool operator<(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::operator <	contains/queue.hpp	/^inline bool operator<(const queue<T, Sequence> &x, const queue<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const queue<T,Sequence> & x,const queue<T,Sequence> & y)
ich::operator <	contains/set.hpp	/^inline bool operator<(const set<Key, Compare, Alloc> &x, const set<Key, Compare, Alloc> &y) { re/;"	f	namespace:ich	typeref:typename:bool	signature:(const set<Key,Compare,Alloc> & x,const set<Key,Compare,Alloc> & y)
ich::operator <	contains/stack.hpp	/^inline bool operator<(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
ich::operator <=	contains/pair.hpp	/^inline bool operator<=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::operator ==	contains/map.hpp	/^inline bool operator==(const map<Key, T, Compare, Alloc> &x, const map<Key, T, Compare, Alloc> &/;"	f	namespace:ich	typeref:typename:bool	signature:(const map<Key,T,Compare,Alloc> & x,const map<Key,T,Compare,Alloc> & y)
ich::operator ==	contains/multimap.hpp	/^inline bool operator==(const multimap<Key, T, Compare, Alloc> &x, const multimap<Key, T, Compare/;"	f	namespace:ich	typeref:typename:bool	signature:(const multimap<Key,T,Compare,Alloc> & x,const multimap<Key,T,Compare,Alloc> & y)
ich::operator ==	contains/multiset.hpp	/^inline bool operator==(const multiset<Key, Compare, Alloc> &x, const multiset<Key, Compare, Allo/;"	f	namespace:ich	typeref:typename:bool	signature:(const multiset<Key,Compare,Alloc> & x,const multiset<Key,Compare,Alloc> & y)
ich::operator ==	contains/pair.hpp	/^inline bool operator==(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::operator ==	contains/queue.hpp	/^inline bool operator==(const queue<T, Sequence> &x, const queue<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const queue<T,Sequence> & x,const queue<T,Sequence> & y)
ich::operator ==	contains/set.hpp	/^inline bool operator==(const set<Key, Compare, Alloc> &x, const set<Key, Compare, Alloc> &y) { r/;"	f	namespace:ich	typeref:typename:bool	signature:(const set<Key,Compare,Alloc> & x,const set<Key,Compare,Alloc> & y)
ich::operator ==	contains/stack.hpp	/^inline bool operator==(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
ich::operator >	contains/pair.hpp	/^inline bool operator>(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::operator >=	contains/pair.hpp	/^inline bool operator>=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
ich::output_iterator_tag	allocator/iterator.hpp	/^struct output_iterator_tag {};$/;"	s	namespace:ich
ich::pair	contains/pair.hpp	/^struct pair$/;"	s	namespace:ich
ich::pair::first	contains/pair.hpp	/^    T1 first;$/;"	m	struct:ich::pair	typeref:typename:T1	access:public
ich::pair::first_type	contains/pair.hpp	/^    typedef T1 first_type;$/;"	t	struct:ich::pair	typeref:typename:T1	access:public
ich::pair::pair	contains/pair.hpp	/^    pair() : first(T1()), second(T2()) {}$/;"	f	struct:ich::pair	access:public	signature:()
ich::pair::pair	contains/pair.hpp	/^    pair(const T1 &_x, const T2 &_y) : first(_x), second(_y) {}$/;"	f	struct:ich::pair	access:public	signature:(const T1 & _x,const T2 & _y)
ich::pair::second	contains/pair.hpp	/^    T2 second;$/;"	m	struct:ich::pair	typeref:typename:T2	access:public
ich::pair::second_type	contains/pair.hpp	/^    typedef T2 second_type;$/;"	t	struct:ich::pair	typeref:typename:T2	access:public
ich::pop_heap	contains/algorithm.hpp	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
ich::pop_heap	contains/algorithm.hpp	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
ich::push_heap	contains/algorithm.hpp	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
ich::push_heap	contains/algorithm.hpp	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
ich::queue	contains/queue.hpp	/^class queue {$/;"	c	namespace:ich
ich::queue::back	contains/queue.hpp	/^    reference back() { return c.back(); }$/;"	f	class:ich::queue	typeref:typename:reference	access:public	signature:()
ich::queue::c	contains/queue.hpp	/^    Sequence c;$/;"	m	class:ich::queue	typeref:typename:Sequence	access:protected
ich::queue::cback	contains/queue.hpp	/^    const_reference cback() const { return c.cback(); }$/;"	f	class:ich::queue	typeref:typename:const_reference	access:public	signature:() const
ich::queue::cfront	contains/queue.hpp	/^    const_reference cfront() const { return c.cfront(); }$/;"	f	class:ich::queue	typeref:typename:const_reference	access:public	signature:() const
ich::queue::const_reference	contains/queue.hpp	/^    typedef typename Sequence::const_reference  const_reference;$/;"	t	class:ich::queue	typeref:typename:Sequence::const_reference	access:public
ich::queue::empty	contains/queue.hpp	/^    bool empty() const { return c.empty(); }$/;"	f	class:ich::queue	typeref:typename:bool	access:public	signature:() const
ich::queue::front	contains/queue.hpp	/^    reference front() { return c.front(); }$/;"	f	class:ich::queue	typeref:typename:reference	access:public	signature:()
ich::queue::pop	contains/queue.hpp	/^    void pop() { c.pop_front(); }$/;"	f	class:ich::queue	typeref:typename:void	access:public	signature:()
ich::queue::push	contains/queue.hpp	/^    void push(const value_type &x) { c.push_back(x); }$/;"	f	class:ich::queue	typeref:typename:void	access:public	signature:(const value_type & x)
ich::queue::reference	contains/queue.hpp	/^    typedef typename Sequence::reference        reference;$/;"	t	class:ich::queue	typeref:typename:Sequence::reference	access:public
ich::queue::size	contains/queue.hpp	/^    size_type size() const { return c.size(); }$/;"	f	class:ich::queue	typeref:typename:size_type	access:public	signature:() const
ich::queue::size_type	contains/queue.hpp	/^    typedef typename Sequence::size_type        size_type;$/;"	t	class:ich::queue	typeref:typename:Sequence::size_type	access:public
ich::queue::value_type	contains/queue.hpp	/^    typedef typename Sequence::value_type       value_type;$/;"	t	class:ich::queue	typeref:typename:Sequence::value_type	access:public
ich::random_access_iterator_tag	allocator/iterator.hpp	/^struct random_access_iterator_tag : public bidirectional_iterator_tag {};$/;"	s	namespace:ich	inherits:bidirectional_iterator_tag
ich::rb_tree	contains/rb_tree.hpp	/^class rb_tree$/;"	c	namespace:ich
ich::rb_tree::__copy	contains/rb_tree.hpp	/^    link_type __copy(link_type x, link_type p);$/;"	p	class:ich::rb_tree	typeref:typename:link_type	access:private	signature:(link_type x,link_type p)
ich::rb_tree::__erase	contains/rb_tree.hpp	/^    void __erase(link_type x) {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:private	signature:(link_type x)
ich::rb_tree::__insert	contains/rb_tree.hpp	/^    iterator __insert(base_ptr x, base_ptr y, const value_type &v);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:private	signature:(base_ptr x,base_ptr y,const value_type & v)
ich::rb_tree::__insert	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__insert(base_ptr x_, base_ptr y_, const Value /;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(base_ptr x_,base_ptr y_,const Value & v)
ich::rb_tree::__rb_tree_rebalance_for_erase	contains/rb_tree.hpp	/^    __rb_tree_node_base* __rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	p	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	access:private	signature:(__rb_tree_node_base * z,__rb_tree_node_base * & root,__rb_tree_node_base * & leftmost,__rb_tree_node_base * & rightmost)
ich::rb_tree::__rb_tree_rebalance_for_erase	contains/rb_tree.hpp	/^__rb_tree_node_base* rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_tree_rebalance_for_er/;"	f	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	signature:(__rb_tree_node_base * z,__rb_tree_node_base * & root,__rb_tree_node_base * & leftmost,__rb_tree_node_base * & rightmost)
ich::rb_tree::base_ptr	contains/rb_tree.hpp	/^    typedef __rb_tree_node_base*    base_ptr;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_node_base *	access:protected
ich::rb_tree::begin	contains/rb_tree.hpp	/^    iterator begin() { return leftmost(); }$/;"	f	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:()
ich::rb_tree::cbegin	contains/rb_tree.hpp	/^    const_iterator cbegin() const { return leftmost(); }$/;"	f	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:() const
ich::rb_tree::cend	contains/rb_tree.hpp	/^    const_iterator cend() const { return header; }$/;"	f	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:() const
ich::rb_tree::clear	contains/rb_tree.hpp	/^    void clear() {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:public	signature:()
ich::rb_tree::clone	contains/rb_tree.hpp	/^    link_type clone(link_type x) {$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
ich::rb_tree::color	contains/rb_tree.hpp	/^    static color_type& color(base_ptr x) { return (color_type&)(x->color); }$/;"	f	class:ich::rb_tree	typeref:typename:color_type &	access:protected	signature:(base_ptr x)
ich::rb_tree::color	contains/rb_tree.hpp	/^    static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:ich::rb_tree	typeref:typename:color_type &	access:protected	signature:(link_type x)
ich::rb_tree::color_type	contains/rb_tree.hpp	/^    typedef __rb_tree_color_type    color_type;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_color_type	access:protected
ich::rb_tree::const_iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<value_type, const_reference, const_pointer> const_iterator;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_iterator<value_type,const_reference,const_pointer>	access:public
ich::rb_tree::const_pointer	contains/rb_tree.hpp	/^    typedef const value_type*   const_pointer;$/;"	t	class:ich::rb_tree	typeref:typename:const value_type *	access:public
ich::rb_tree::const_reference	contains/rb_tree.hpp	/^    typedef const value_type&   const_reference;$/;"	t	class:ich::rb_tree	typeref:typename:const value_type &	access:public
ich::rb_tree::count	contains/rb_tree.hpp	/^    size_type count(const key_type &x) const;$/;"	p	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:(const key_type & x) const
ich::rb_tree::count	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::size_type	signature:(const Key & k) const
ich::rb_tree::create_node	contains/rb_tree.hpp	/^    link_type create_node(const value_type &x) {$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(const value_type & x)
ich::rb_tree::destroy_node	contains/rb_tree.hpp	/^    void destroy_node(link_type p) {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:protected	signature:(link_type p)
ich::rb_tree::difference_type	contains/rb_tree.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	class:ich::rb_tree	typeref:typename:ptrdiff_t	access:public
ich::rb_tree::empty	contains/rb_tree.hpp	/^    bool empty() const { return node_count == 0; }$/;"	f	class:ich::rb_tree	typeref:typename:bool	access:public	signature:() const
ich::rb_tree::end	contains/rb_tree.hpp	/^    iterator end() const { return header; }$/;"	f	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:() const
ich::rb_tree::equal_range	contains/rb_tree.hpp	/^    pair<const_iterator, const_iterator> equal_range(const Key &k) const { return pair<const_ite/;"	f	class:ich::rb_tree	typeref:typename:pair<const_iterator,const_iterator>	access:public	signature:(const Key & k) const
ich::rb_tree::equal_range	contains/rb_tree.hpp	/^    pair<iterator, iterator> equal_range(const Key &k) { return pair<iterator, iterator>(lower_b/;"	f	class:ich::rb_tree	typeref:typename:pair<iterator,iterator>	access:public	signature:(const Key & k)
ich::rb_tree::erase	contains/rb_tree.hpp	/^    size_type erase(const Key &x);$/;"	p	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:(const Key & x)
ich::rb_tree::erase	contains/rb_tree.hpp	/^    void erase(const Key *first, const Key *last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(const Key * first,const Key * last)
ich::rb_tree::erase	contains/rb_tree.hpp	/^    void erase(iterator first, iterator last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(iterator first,iterator last)
ich::rb_tree::erase	contains/rb_tree.hpp	/^    void erase(iterator position);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(iterator position)
ich::rb_tree::erase	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key &x) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::size_type	signature:(const Key & x)
ich::rb_tree::erase	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(iterator first,iterator last)
ich::rb_tree::erase	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(iterator position)
ich::rb_tree::find	contains/rb_tree.hpp	/^    iterator find(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k) const
ich::rb_tree::find	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k) const
ich::rb_tree::get_node	contains/rb_tree.hpp	/^    link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:()
ich::rb_tree::header	contains/rb_tree.hpp	/^    link_type   header;$/;"	m	class:ich::rb_tree	typeref:typename:link_type	access:protected
ich::rb_tree::init	contains/rb_tree.hpp	/^    void init() {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:private	signature:()
ich::rb_tree::insert_equal	contains/rb_tree.hpp	/^    iterator insert_equal(const value_type &x);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const value_type & x)
ich::rb_tree::insert_equal	contains/rb_tree.hpp	/^    void insert_equal(II first, II last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(II first,II last)
ich::rb_tree::insert_equal	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value &v) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Value & v)
ich::rb_tree::insert_equal	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(II first, II last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(II first,II last)
ich::rb_tree::insert_unique	contains/rb_tree.hpp	/^    pair<iterator, bool> insert_unique(const value_type &x);$/;"	p	class:ich::rb_tree	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & x)
ich::rb_tree::insert_unique	contains/rb_tree.hpp	/^    void insert_unique(II first, II last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(II first,II last)
ich::rb_tree::insert_unique	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value &v) {$/;"	f	class:ich::rb_tree	typeref:typename:pair<typename rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator,bool>	signature:(const Value & v)
ich::rb_tree::insert_unique	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(II first, II last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(II first,II last)
ich::rb_tree::iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_iterator<value_type,reference,pointer>	access:public
ich::rb_tree::key	contains/rb_tree.hpp	/^    static const Key& key(base_ptr x) { return KeyOfValue()(value(x)); }$/;"	f	class:ich::rb_tree	typeref:typename:const Key &	access:protected	signature:(base_ptr x)
ich::rb_tree::key	contains/rb_tree.hpp	/^    static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:ich::rb_tree	typeref:typename:const Key &	access:protected	signature:(link_type x)
ich::rb_tree::key_comp	contains/rb_tree.hpp	/^    Compare key_comp() const { return key_compare; }$/;"	f	class:ich::rb_tree	typeref:typename:Compare	access:public	signature:() const
ich::rb_tree::key_compare	contains/rb_tree.hpp	/^    Compare     key_compare;\/\/ 键值比较规则$/;"	m	class:ich::rb_tree	typeref:typename:Compare	access:protected
ich::rb_tree::key_type	contains/rb_tree.hpp	/^    typedef Key                 key_type;$/;"	t	class:ich::rb_tree	typeref:typename:Key	access:public
ich::rb_tree::left	contains/rb_tree.hpp	/^     static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
ich::rb_tree::left	contains/rb_tree.hpp	/^    static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
ich::rb_tree::leftmost	contains/rb_tree.hpp	/^    link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
ich::rb_tree::link_type	contains/rb_tree.hpp	/^    typedef rb_tree_node*       link_type;$/;"	t	class:ich::rb_tree	typeref:typename:rb_tree_node *	access:public
ich::rb_tree::lower_bound	contains/rb_tree.hpp	/^    const_iterator lower_bound(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:(const Key & k) const
ich::rb_tree::lower_bound	contains/rb_tree.hpp	/^    iterator lower_bound(const Key &k);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k)
ich::rb_tree::lower_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::const_iterator	signature:(const Key & k) const
ich::rb_tree::lower_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key &k) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k)
ich::rb_tree::max_size	contains/rb_tree.hpp	/^    size_type max_size() const { return size_type(-1); }$/;"	f	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:() const
ich::rb_tree::maximum	contains/rb_tree.hpp	/^    static link_type maximum(link_type x) { return (link_type) __rb_tree_node_base::maximum(x); /;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
ich::rb_tree::minimum	contains/rb_tree.hpp	/^    static link_type minimum(link_type x) { return (link_type) __rb_tree_node_base::minimum(x); /;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
ich::rb_tree::node_count	contains/rb_tree.hpp	/^    size_type   node_count; \/\/ 节点数量$/;"	m	class:ich::rb_tree	typeref:typename:size_type	access:protected
ich::rb_tree::operator =	contains/rb_tree.hpp	/^        operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc> &x);$/;"	p	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc> &	access:public	signature:(const rb_tree<Key,Value,KeyOfValue,Compare,Alloc> & x)
ich::rb_tree::parent	contains/rb_tree.hpp	/^    static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
ich::rb_tree::parent	contains/rb_tree.hpp	/^    static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
ich::rb_tree::pointer	contains/rb_tree.hpp	/^    typedef value_type*         pointer;$/;"	t	class:ich::rb_tree	typeref:typename:value_type *	access:public
ich::rb_tree::put_node	contains/rb_tree.hpp	/^    void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:ich::rb_tree	typeref:typename:void	access:protected	signature:(link_type p)
ich::rb_tree::rb_tree	contains/rb_tree.hpp	/^    rb_tree(const Compare &comp = Compare()) : node_count(0), key_compare(comp) { init(); }$/;"	f	class:ich::rb_tree	access:public	signature:(const Compare & comp=Compare ())
ich::rb_tree::rb_tree_node	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>   rb_tree_node;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_node<Value>	access:protected
ich::rb_tree::rb_tree_node_allocator	contains/rb_tree.hpp	/^    typedef allocator<rb_tree_node> rb_tree_node_allocator;$/;"	t	class:ich::rb_tree	typeref:typename:allocator<rb_tree_node>	access:protected
ich::rb_tree::reference	contains/rb_tree.hpp	/^    typedef value_type&         reference;$/;"	t	class:ich::rb_tree	typeref:typename:value_type &	access:public
ich::rb_tree::right	contains/rb_tree.hpp	/^    static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
ich::rb_tree::right	contains/rb_tree.hpp	/^    static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
ich::rb_tree::rightmost	contains/rb_tree.hpp	/^    link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
ich::rb_tree::root	contains/rb_tree.hpp	/^    link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
ich::rb_tree::size	contains/rb_tree.hpp	/^    size_type size() const { return node_count; }$/;"	f	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:() const
ich::rb_tree::size_type	contains/rb_tree.hpp	/^    typedef size_t              size_type;$/;"	t	class:ich::rb_tree	typeref:typename:size_t	access:public
ich::rb_tree::upper_bound	contains/rb_tree.hpp	/^    const_iterator upper_bound(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:(const Key & k) const
ich::rb_tree::upper_bound	contains/rb_tree.hpp	/^    iterator upper_bound(const Key &k);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k)
ich::rb_tree::upper_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::const_iterator	signature:(const Key & k) const
ich::rb_tree::upper_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key &k) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k)
ich::rb_tree::value	contains/rb_tree.hpp	/^    static reference value(base_ptr x) { return link_type(x)->value_field; }$/;"	f	class:ich::rb_tree	typeref:typename:reference	access:protected	signature:(base_ptr x)
ich::rb_tree::value	contains/rb_tree.hpp	/^    static reference value(link_type x) { return x->value_field; }$/;"	f	class:ich::rb_tree	typeref:typename:reference	access:protected	signature:(link_type x)
ich::rb_tree::value_type	contains/rb_tree.hpp	/^    typedef Value               value_type;$/;"	t	class:ich::rb_tree	typeref:typename:Value	access:public
ich::rb_tree::void_pointer	contains/rb_tree.hpp	/^    typedef void*                   void_pointer;$/;"	t	class:ich::rb_tree	typeref:typename:void *	access:protected
ich::rb_tree::~rb_tree	contains/rb_tree.hpp	/^    ~rb_tree() { clear(); put_node(header); }$/;"	f	class:ich::rb_tree	access:public	signature:()
ich::set	contains/set.hpp	/^class set {$/;"	c	namespace:ich
ich::set::begin	contains/set.hpp	/^    iterator begin() { return t.begin(); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:()
ich::set::cbegin	contains/set.hpp	/^    const_iterator cbegin() const { return t.cbegin(); }$/;"	f	class:ich::set	typeref:typename:const_iterator	access:public	signature:() const
ich::set::cend	contains/set.hpp	/^    const_iterator cend() const { return t.cend(); }$/;"	f	class:ich::set	typeref:typename:const_iterator	access:public	signature:() const
ich::set::clear	contains/set.hpp	/^    void clear() { t.clear(); }$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:()
ich::set::const_iterator	contains/set.hpp	/^    typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:ich::set	typeref:typename:rep_type::const_iterator	access:public
ich::set::const_pointer	contains/set.hpp	/^    typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:ich::set	typeref:typename:rep_type::const_pointer	access:public
ich::set::const_reference	contains/set.hpp	/^    typedef typename rep_type::const_reference const_reference;$/;"	t	class:ich::set	typeref:typename:rep_type::const_reference	access:public
ich::set::count	contains/set.hpp	/^    size_type count(const key_type &x) const { return t.count(x); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:(const key_type & x) const
ich::set::difference_type	contains/set.hpp	/^    typedef typename rep_type::difference_type difference_type;$/;"	t	class:ich::set	typeref:typename:rep_type::difference_type	access:public
ich::set::empty	contains/set.hpp	/^    bool empty() const { return t.empty(); }$/;"	f	class:ich::set	typeref:typename:bool	access:public	signature:() const
ich::set::end	contains/set.hpp	/^    iterator end() { return t.end(); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:()
ich::set::equal_range	contains/set.hpp	/^    pair<iterator, iterator> equal_range(const key_type &x) const { return t.equal_range(x); }$/;"	f	class:ich::set	typeref:typename:pair<iterator,iterator>	access:public	signature:(const key_type & x) const
ich::set::erase	contains/set.hpp	/^    size_type erase(const key_type &x) {$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:(const key_type & x)
ich::set::erase	contains/set.hpp	/^    void erase(iterator first, iterator last) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(iterator first,iterator last)
ich::set::erase	contains/set.hpp	/^    void erase(iterator position) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(iterator position)
ich::set::find	contains/set.hpp	/^    iterator find(const key_type &x) const { return t.find(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::set::insert	contains/set.hpp	/^    iterator insert(iterator position, const value_type &x) {$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
ich::set::insert	contains/set.hpp	/^    pair<iterator, bool> insert(const value_type &x) {$/;"	f	class:ich::set	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & x)
ich::set::insert	contains/set.hpp	/^    void insert(InputIterator first, InputIterator last) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
ich::set::iterator	contains/set.hpp	/^    typedef typename rep_type::const_iterator iterator;$/;"	t	class:ich::set	typeref:typename:rep_type::const_iterator	access:public
ich::set::key_comp	contains/set.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::set	typeref:typename:key_compare	access:public	signature:() const
ich::set::key_compare	contains/set.hpp	/^    typedef Compare key_compare;$/;"	t	class:ich::set	typeref:typename:Compare	access:public
ich::set::key_type	contains/set.hpp	/^    typedef Key key_type;$/;"	t	class:ich::set	typeref:typename:Key	access:public
ich::set::lower_bound	contains/set.hpp	/^    iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::set::max_size	contains/set.hpp	/^    size_type max_size() const { return t.max_size(); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:() const
ich::set::operator =	contains/set.hpp	/^    set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc> &x) { t = x.t; return *th/;"	f	class:ich::set	typeref:typename:set<Key,Compare,Alloc> &	access:public	signature:(const set<Key,Compare,Alloc> & x)
ich::set::pair_iterator_bool	contains/set.hpp	/^    typedef pair<iterator, bool> pair_iterator_bool;$/;"	t	class:ich::set	typeref:typename:pair<iterator,bool>	access:public
ich::set::pointer	contains/set.hpp	/^    typedef typename rep_type::const_pointer pointer;$/;"	t	class:ich::set	typeref:typename:rep_type::const_pointer	access:public
ich::set::reference	contains/set.hpp	/^    typedef typename rep_type::const_reference reference;$/;"	t	class:ich::set	typeref:typename:rep_type::const_reference	access:public
ich::set::rep_type	contains/set.hpp	/^    typedef rb_tree<key_type, value_type, identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:ich::set	typeref:typename:rb_tree<key_type,value_type,identity<value_type>,key_compare,Alloc>	access:private
ich::set::set	contains/set.hpp	/^    explicit set(const Compare &comp) : t(comp) {}$/;"	f	class:ich::set	access:public	signature:(const Compare & comp)
ich::set::set	contains/set.hpp	/^    set() : t(Compare()) {}$/;"	f	class:ich::set	access:public	signature:()
ich::set::set	contains/set.hpp	/^    set(InputIterator first, InputIterator last) : t(Compare()) { t.insert_unique(first, last); /;"	f	class:ich::set	access:public	signature:(InputIterator first,InputIterator last)
ich::set::set	contains/set.hpp	/^    set(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_uniqu/;"	f	class:ich::set	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
ich::set::set	contains/set.hpp	/^    set(const set<Key, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::set	access:public	signature:(const set<Key,Compare,Alloc> & x)
ich::set::size	contains/set.hpp	/^    size_type size() const { return t.size(); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:() const
ich::set::size_type	contains/set.hpp	/^    typedef typename rep_type::size_type size_type;$/;"	t	class:ich::set	typeref:typename:rep_type::size_type	access:public
ich::set::swap	contains/set.hpp	/^    void swap(set<Key, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(set<Key,Compare,Alloc> & x)
ich::set::t	contains/set.hpp	/^    rep_type t; \/\/ 用红黑树来表现set$/;"	m	class:ich::set	typeref:typename:rep_type	access:private
ich::set::upper_bound	contains/set.hpp	/^    iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
ich::set::value_comp	contains/set.hpp	/^    value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:ich::set	typeref:typename:value_compare	access:public	signature:() const
ich::set::value_compare	contains/set.hpp	/^    typedef Compare value_compare;$/;"	t	class:ich::set	typeref:typename:Compare	access:public
ich::set::value_type	contains/set.hpp	/^    typedef Key value_type;$/;"	t	class:ich::set	typeref:typename:Key	access:public
ich::slist	contains/slist.hpp	/^class slist$/;"	c	namespace:ich
ich::slist::begin	contains/slist.hpp	/^    iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:()
ich::slist::clear	contains/slist.hpp	/^    void clear() {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:()
ich::slist::const_iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator<T,const T &,const T * >	access:public
ich::slist::const_pointer	contains/slist.hpp	/^    typedef const value_type*   const_pointer;$/;"	t	class:ich::slist	typeref:typename:const value_type *	access:public
ich::slist::const_reference	contains/slist.hpp	/^    typedef const value_type&   const_reference;$/;"	t	class:ich::slist	typeref:typename:const value_type &	access:public
ich::slist::create_node	contains/slist.hpp	/^    static list_node* create_node(const value_type &x) {$/;"	f	class:ich::slist	typeref:typename:list_node *	access:private	signature:(const value_type & x)
ich::slist::destroy_node	contains/slist.hpp	/^    static void destroy_node(list_node *node) {$/;"	f	class:ich::slist	typeref:typename:void	access:private	signature:(list_node * node)
ich::slist::difference_type	contains/slist.hpp	/^    typedef ptrdiff_t           difference_type;$/;"	t	class:ich::slist	typeref:typename:ptrdiff_t	access:public
ich::slist::empty	contains/slist.hpp	/^    bool empty() const { return head.next == 0; }$/;"	f	class:ich::slist	typeref:typename:bool	access:public	signature:() const
ich::slist::end	contains/slist.hpp	/^    iterator end() { return iterator(0); }$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:()
ich::slist::erase	contains/slist.hpp	/^    iterator erase(iterator it) {$/;"	f	class:ich::slist	typeref:typename:iterator	access:public	signature:(iterator it)
ich::slist::front	contains/slist.hpp	/^    reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:ich::slist	typeref:typename:reference	access:public	signature:()
ich::slist::head	contains/slist.hpp	/^    list_node_base head;$/;"	m	class:ich::slist	typeref:typename:list_node_base	access:private
ich::slist::insert	contains/slist.hpp	/^    void insert(iterator it, const value_type &x) {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(iterator it,const value_type & x)
ich::slist::iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator<T,T &,T * >	access:public
ich::slist::iterator_base	contains/slist.hpp	/^    typedef __slist_iterator_base   iterator_base;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator_base	access:private
ich::slist::list_node	contains/slist.hpp	/^    typedef __slist_node<T>         list_node;$/;"	t	class:ich::slist	typeref:typename:__slist_node<T>	access:private
ich::slist::list_node_allocator	contains/slist.hpp	/^    typedef allocator<list_node>    list_node_allocator;$/;"	t	class:ich::slist	typeref:typename:allocator<list_node>	access:private
ich::slist::list_node_base	contains/slist.hpp	/^    typedef __slist_node_base       list_node_base;$/;"	t	class:ich::slist	typeref:typename:__slist_node_base	access:private
ich::slist::pointer	contains/slist.hpp	/^    typedef value_type*         pointer;$/;"	t	class:ich::slist	typeref:typename:value_type *	access:public
ich::slist::pop_front	contains/slist.hpp	/^    void pop_front() {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:()
ich::slist::push_front	contains/slist.hpp	/^    void push_front(const value_type &x) { __slist_make_link(&head, create_node(x)); }$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(const value_type & x)
ich::slist::reference	contains/slist.hpp	/^    typedef value_type&         reference;$/;"	t	class:ich::slist	typeref:typename:value_type &	access:public
ich::slist::size	contains/slist.hpp	/^    size_type size() const { return  __slist_size(head.next); }$/;"	f	class:ich::slist	typeref:typename:size_type	access:public	signature:() const
ich::slist::size_type	contains/slist.hpp	/^    typedef size_t              size_type;$/;"	t	class:ich::slist	typeref:typename:size_t	access:public
ich::slist::slist	contains/slist.hpp	/^    slist() { head.next = 0; }$/;"	f	class:ich::slist	access:public	signature:()
ich::slist::swap	contains/slist.hpp	/^    void swap(slist &L) {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(slist & L)
ich::slist::value_type	contains/slist.hpp	/^    typedef T                   value_type;$/;"	t	class:ich::slist	typeref:typename:T	access:public
ich::slist::~slist	contains/slist.hpp	/^    ~slist() { clear(); }$/;"	f	class:ich::slist	access:public	signature:()
ich::sort_heap	contains/algorithm.hpp	/^inline void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
ich::stack	contains/stack.hpp	/^class stack {$/;"	c	namespace:ich
ich::stack::c	contains/stack.hpp	/^    Sequence c;$/;"	m	class:ich::stack	typeref:typename:Sequence	access:protected
ich::stack::const_reference	contains/stack.hpp	/^    typedef typename Sequence::const_reference  const_reference;$/;"	t	class:ich::stack	typeref:typename:Sequence::const_reference	access:public
ich::stack::ctop	contains/stack.hpp	/^    const_reference ctop() const { return c.cback(); }$/;"	f	class:ich::stack	typeref:typename:const_reference	access:public	signature:() const
ich::stack::empty	contains/stack.hpp	/^    bool empty() const { return c.empty(); }$/;"	f	class:ich::stack	typeref:typename:bool	access:public	signature:() const
ich::stack::pop	contains/stack.hpp	/^    void pop() { c.pop_back(); }$/;"	f	class:ich::stack	typeref:typename:void	access:public	signature:()
ich::stack::push	contains/stack.hpp	/^    void push(const value_type &x) { c.push_back(x); }$/;"	f	class:ich::stack	typeref:typename:void	access:public	signature:(const value_type & x)
ich::stack::reference	contains/stack.hpp	/^    typedef typename Sequence::reference        reference;$/;"	t	class:ich::stack	typeref:typename:Sequence::reference	access:public
ich::stack::size	contains/stack.hpp	/^    size_type size() const { return c.size(); }$/;"	f	class:ich::stack	typeref:typename:size_type	access:public	signature:() const
ich::stack::size_type	contains/stack.hpp	/^    typedef typename Sequence::size_type        size_type;$/;"	t	class:ich::stack	typeref:typename:Sequence::size_type	access:public
ich::stack::top	contains/stack.hpp	/^    reference top() { return c.back(); }$/;"	f	class:ich::stack	typeref:typename:reference	access:public	signature:()
ich::stack::value_type	contains/stack.hpp	/^    typedef typename Sequence::value_type       value_type;$/;"	t	class:ich::stack	typeref:typename:Sequence::value_type	access:public
ich::swap	contains/algorithm.hpp	/^void swap(T1 &left, T2 &right) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T1 & left,T2 & right)
ich::uninitialized_copy	allocator/uninitialized.hpp	/^ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator resu/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result)
ich::uninitialized_copy	allocator/uninitialized.hpp	/^inline char* uninitialized_copy(const char *first, const char *last, char *result) {$/;"	f	namespace:ich	typeref:typename:char *	signature:(const char * first,const char * last,char * result)
ich::uninitialized_copy	allocator/uninitialized.hpp	/^inline wchar_t* uninitialized_copy(const wchar_t *first, const wchar_t *last, wchar_t *result) {$/;"	f	namespace:ich	typeref:typename:wchar_t *	signature:(const wchar_t * first,const wchar_t * last,wchar_t * result)
ich::uninitialized_fill	allocator/uninitialized.hpp	/^void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &x) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x)
ich::uninitialized_fill_n	allocator/uninitialized.hpp	/^inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T &x) {$/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x)
ich::value_type	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::value_type* value_type(const Iterator&) {$/;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::value_type *	signature:(const Iterator &)
ich::vector	contains/vector.hpp	/^class vector {$/;"	c	namespace:ich
ich::vector::allocate_and_copy	contains/vector.hpp	/^    iterator allocate_and_copy(size_type n, iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(size_type n,iterator first,iterator last)
ich::vector::allocate_and_fill	contains/vector.hpp	/^    iterator allocate_and_fill(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(iterator first,iterator last)
ich::vector::allocate_and_fill	contains/vector.hpp	/^    iterator allocate_and_fill(size_type n, const T &x) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:protected	signature:(size_type n,const T & x)
ich::vector::back	contains/vector.hpp	/^    reference back() { return *(end() - 1); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:()
ich::vector::begin	contains/vector.hpp	/^    iterator begin() { return start; }$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:()
ich::vector::capacity	contains/vector.hpp	/^    size_type capacity() const { return size_type(end_of_storage - cbegin()); }$/;"	f	class:ich::vector	typeref:typename:size_type	access:public	signature:() const
ich::vector::cbegin	contains/vector.hpp	/^    const_iterator cbegin() const { return start; }$/;"	f	class:ich::vector	typeref:typename:const_iterator	access:public	signature:() const
ich::vector::cend	contains/vector.hpp	/^    const_iterator cend() const { return finish; }$/;"	f	class:ich::vector	typeref:typename:const_iterator	access:public	signature:() const
ich::vector::clear	contains/vector.hpp	/^    void clear() { erase(begin(), end()); }$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:()
ich::vector::const_iterator	contains/vector.hpp	/^    typedef const value_type* const_iterator;$/;"	t	class:ich::vector	typeref:typename:const value_type *	access:public
ich::vector::const_reference	contains/vector.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:ich::vector	typeref:typename:const value_type &	access:public
ich::vector::data_allocator	contains/vector.hpp	/^    typedef Alloc data_allocator;$/;"	t	class:ich::vector	typeref:typename:Alloc	access:protected
ich::vector::deallocate	contains/vector.hpp	/^    void deallocate() { if (start) data_allocator::deallocate(start, end_of_storage - start); }$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:()
ich::vector::difference_type	contains/vector.hpp	/^    typedef ptrdiff_t   difference_type;$/;"	t	class:ich::vector	typeref:typename:ptrdiff_t	access:public
ich::vector::empty	contains/vector.hpp	/^    bool empty() const { return cbegin() == cend(); }$/;"	f	class:ich::vector	typeref:typename:bool	access:public	signature:() const
ich::vector::end	contains/vector.hpp	/^    iterator end() { return finish; }$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:()
ich::vector::end_of_storage	contains/vector.hpp	/^    iterator end_of_storage;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
ich::vector::erase	contains/vector.hpp	/^    iterator erase(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:(iterator first,iterator last)
ich::vector::erase	contains/vector.hpp	/^    iterator erase(iterator position) {$/;"	f	class:ich::vector	typeref:typename:iterator	access:public	signature:(iterator position)
ich::vector::fill_initialize	contains/vector.hpp	/^    void fill_initialize(iterator first, iterator last) {$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:(iterator first,iterator last)
ich::vector::fill_initialize	contains/vector.hpp	/^    void fill_initialize(size_type n, const T &value) {$/;"	f	class:ich::vector	typeref:typename:void	access:protected	signature:(size_type n,const T & value)
ich::vector::finish	contains/vector.hpp	/^    iterator finish;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
ich::vector::front	contains/vector.hpp	/^    reference front() { return *begin(); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:()
ich::vector::insert	contains/vector.hpp	/^    void insert(iterator position, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(iterator position,const T & x)
ich::vector::insert	contains/vector.hpp	/^    void insert(iterator position, size_type n, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(iterator position,size_type n,const T & x)
ich::vector::insert	contains/vector.hpp	/^void vector<T, Alloc>::insert(iterator position, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,const T & x)
ich::vector::insert	contains/vector.hpp	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,size_type n,const T & x)
ich::vector::insert_aux	contains/vector.hpp	/^    void insert_aux(iterator position, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:protected	signature:(iterator position,const T & x)
ich::vector::insert_aux	contains/vector.hpp	/^void vector<T, Alloc>::insert_aux(iterator position, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,const T & x)
ich::vector::iterator	contains/vector.hpp	/^    typedef value_type* iterator;$/;"	t	class:ich::vector	typeref:typename:value_type *	access:public
ich::vector::operator [] 	contains/vector.hpp	/^    const_reference operator[] (size_type n) const { return *(cbegin() + n); }$/;"	f	class:ich::vector	typeref:typename:const_reference	access:public	signature:(size_type n) const
ich::vector::operator [] 	contains/vector.hpp	/^    reference operator[] (size_type n) { return *(begin() + n); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:(size_type n)
ich::vector::pointer	contains/vector.hpp	/^    typedef value_type* pointer;$/;"	t	class:ich::vector	typeref:typename:value_type *	access:public
ich::vector::pop_back	contains/vector.hpp	/^    void pop_back() {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:()
ich::vector::push_back	contains/vector.hpp	/^    void push_back(const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(const T & x)
ich::vector::reference	contains/vector.hpp	/^    typedef value_type& reference;$/;"	t	class:ich::vector	typeref:typename:value_type &	access:public
ich::vector::reserve	contains/vector.hpp	/^    void reserve(size_type n);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(size_type n)
ich::vector::reserve	contains/vector.hpp	/^void vector<T, Alloc>::reserve(size_type n) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(size_type n)
ich::vector::resize	contains/vector.hpp	/^    void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(size_type new_size)
ich::vector::resize	contains/vector.hpp	/^    void resize(size_type new_size, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(size_type new_size,const T & x)
ich::vector::size	contains/vector.hpp	/^    size_type size() const { return size_type(cend() - cbegin()); }$/;"	f	class:ich::vector	typeref:typename:size_type	access:public	signature:() const
ich::vector::size_type	contains/vector.hpp	/^    typedef size_t      size_type;$/;"	t	class:ich::vector	typeref:typename:size_t	access:public
ich::vector::start	contains/vector.hpp	/^    iterator start;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
ich::vector::swap	contains/vector.hpp	/^    void swap(vector<T, Alloc> &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(vector<T,Alloc> & x)
ich::vector::value_type	contains/vector.hpp	/^    typedef T           value_type;$/;"	t	class:ich::vector	typeref:typename:T	access:public
ich::vector::vector	contains/vector.hpp	/^    explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:ich::vector	access:public	signature:(size_type n)
ich::vector::vector	contains/vector.hpp	/^    vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:ich::vector	access:public	signature:()
ich::vector::vector	contains/vector.hpp	/^    vector(int n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(int n,const T & value)
ich::vector::vector	contains/vector.hpp	/^    vector(iterator first, iterator last) { fill_initialize(first, last); }$/;"	f	class:ich::vector	access:public	signature:(iterator first,iterator last)
ich::vector::vector	contains/vector.hpp	/^    vector(long n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(long n,const T & value)
ich::vector::vector	contains/vector.hpp	/^    vector(size_type n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(size_type n,const T & value)
ich::vector::~vector	contains/vector.hpp	/^    ~vector() {$/;"	f	class:ich::vector	access:public	signature:()
icopy	contains/algorithm.hpp	/^OutputIt icopy(InputIt first, InputIt last, OutputIt d_first) {$/;"	f	namespace:ich	typeref:typename:OutputIt	signature:(InputIt first,InputIt last,OutputIt d_first)
identity	contains/algorithm.hpp	/^struct identity \/*: public unary_function<T, T> *\/$/;"	s	namespace:ich
iiiiiiiiii	confusing_syntax/some_confusing_syntax.cpp	/^#define iiiiiiiiii /;"	d	file:
incr	contains/slist.hpp	/^    void incr() { node = node->next; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:void	access:public	signature:()
increment	contains/rb_tree.hpp	/^    void increment() {$/;"	f	struct:ich::__rb_tree_base_iterator	typeref:typename:void	access:public	signature:()
init	contains/rb_tree.hpp	/^    void init() {$/;"	f	class:ich::rb_tree	typeref:typename:void	access:private	signature:()
init_page_size	allocator/std_allocator.hpp	/^    size_type init_page_size() {$/;"	f	class:allocator	typeref:typename:size_type	access:public	signature:()
initial_map_size	contains/deque.hpp	/^    size_type initial_map_size() { return INITIAL_MAP_SIZE; }$/;"	f	class:ich::deque	typeref:typename:size_type	access:protected	signature:()
initialize_buckets	contains/hashtable.hpp	/^    void initialize_buckets(size_type n) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(size_type n)
input_iterator_tag	allocator/iterator.hpp	/^struct input_iterator_tag {};$/;"	s	namespace:ich
insert	confusing_syntax/some_confusing_syntax.cpp	/^    void insert(iterator position, I first, I last) {$/;"	f	class:vector	typeref:typename:void	file:	access:public	signature:(iterator position,I first,I last)
insert	contains/deque.hpp	/^    iterator insert(iterator position, const value_type &x);$/;"	p	class:ich::deque	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
insert	contains/deque.hpp	/^deque<T, Alloc, BufSize>::insert(iterator position, const value_type &x) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator position,const value_type & x)
insert	contains/list_temp.hpp	/^    iterator insert(iterator position, const T &x) {$/;"	f	class:ich::list	typeref:typename:iterator	access:public	signature:(iterator position,const T & x)
insert	contains/map.hpp	/^    iterator insert(iterator position, const value_type &x) { return t.insert_unique(position, x/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
insert	contains/map.hpp	/^    std::pair<iterator, bool> insert(const value_type &x) { return t.insert_unique(x); }$/;"	f	class:ich::map	typeref:typename:std::pair<iterator,bool>	access:public	signature:(const value_type & x)
insert	contains/map.hpp	/^    void insert(InputIterator first, InputIterator last) { t.insert_unique(first, last); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
insert	contains/multimap.hpp	/^    iterator insert(iterator position, const value_type &x) { return t.insert_equal(position, x)/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
insert	contains/multimap.hpp	/^    std::pair<iterator, bool> insert(const value_type &x) { return t.insert_equal(x); }$/;"	f	class:ich::multimap	typeref:typename:std::pair<iterator,bool>	access:public	signature:(const value_type & x)
insert	contains/multimap.hpp	/^    void insert(InputIterator first, InputIterator last) { t.insert_equal(first, last); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
insert	contains/multiset.hpp	/^    iterator insert(const value_type &x) {$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const value_type & x)
insert	contains/multiset.hpp	/^    iterator insert(iterator position, const value_type &x) {$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
insert	contains/multiset.hpp	/^    void insert(InputIterator first, InputIterator last) {$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
insert	contains/set.hpp	/^    iterator insert(iterator position, const value_type &x) {$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(iterator position,const value_type & x)
insert	contains/set.hpp	/^    pair<iterator, bool> insert(const value_type &x) {$/;"	f	class:ich::set	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & x)
insert	contains/set.hpp	/^    void insert(InputIterator first, InputIterator last) {$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(InputIterator first,InputIterator last)
insert	contains/slist.hpp	/^    void insert(iterator it, const value_type &x) {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(iterator it,const value_type & x)
insert	contains/vector.hpp	/^    void insert(iterator position, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(iterator position,const T & x)
insert	contains/vector.hpp	/^    void insert(iterator position, size_type n, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(iterator position,size_type n,const T & x)
insert	contains/vector.hpp	/^void vector<T, Alloc>::insert(iterator position, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,const T & x)
insert	contains/vector.hpp	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,size_type n,const T & x)
insert_aux	contains/deque.hpp	/^    iterator insert_aux(iterator pos, const value_type &x);$/;"	p	class:ich::deque	typeref:typename:iterator	access:protected	signature:(iterator pos,const value_type & x)
insert_aux	contains/deque.hpp	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type &x) {$/;"	f	class:ich::deque	typeref:typename:deque<T,Alloc,BufSize>::iterator	signature:(iterator pos,const value_type & x)
insert_aux	contains/vector.hpp	/^    void insert_aux(iterator position, const T &x);$/;"	p	class:ich::vector	typeref:typename:void	access:protected	signature:(iterator position,const T & x)
insert_aux	contains/vector.hpp	/^void vector<T, Alloc>::insert_aux(iterator position, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(iterator position,const T & x)
insert_equal	contains/hashtable.hpp	/^    iterator insert_equal(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const value_type & obj)
insert_equal	contains/rb_tree.hpp	/^    iterator insert_equal(const value_type &x);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const value_type & x)
insert_equal	contains/rb_tree.hpp	/^    void insert_equal(II first, II last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(II first,II last)
insert_equal	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value &v) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Value & v)
insert_equal	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(II first, II last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(II first,II last)
insert_equal_noresize	contains/hashtable.hpp	/^    iterator insert_equal_noresize(const value_type &obj);$/;"	p	class:ich::hashtable	typeref:typename:iterator	access:public	signature:(const value_type & obj)
insert_equal_noresize	contains/hashtable.hpp	/^hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::insert_equal_noresize(const value_t/;"	f	class:ich::hashtable	typeref:typename:hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>::iterator	signature:(const value_type & obj)
insert_unique	contains/hashtable.hpp	/^    pair<iterator, bool> insert_unique(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & obj)
insert_unique	contains/rb_tree.hpp	/^    pair<iterator, bool> insert_unique(const value_type &x);$/;"	p	class:ich::rb_tree	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & x)
insert_unique	contains/rb_tree.hpp	/^    void insert_unique(II first, II last);$/;"	p	class:ich::rb_tree	typeref:typename:void	access:public	signature:(II first,II last)
insert_unique	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value &v) {$/;"	f	class:ich::rb_tree	typeref:typename:pair<typename rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator,bool>	signature:(const Value & v)
insert_unique	contains/rb_tree.hpp	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(II first, II last) {$/;"	f	class:ich::rb_tree	typeref:typename:void	signature:(II first,II last)
insert_unique_noresize	contains/hashtable.hpp	/^    pair<iterator, bool> insert_unique_noresize(const value_type &obj);$/;"	p	class:ich::hashtable	typeref:typename:pair<iterator,bool>	access:public	signature:(const value_type & obj)
insert_unique_noresize	contains/hashtable.hpp	/^hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::insert_unique_noresize(const value_/;"	f	class:ich::hashtable	typeref:typename:pair<typename hashtable<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>::iterator,bool>	signature:(const value_type & obj)
is_POD	allocator/uninitialized.hpp	/^    typedef typename __type_traits<T1>::is_POD_type is_POD;$/;"	t	function:ich::__uninitialized_fill	typeref:typename:__type_traits<T1>::is_POD_type
is_POD	allocator/uninitialized.hpp	/^    typedef typename __type_traits<T1>::is_POD_type is_POD;$/;"	t	function:ich::__uninitialized_fill_n	typeref:typename:__type_traits<T1>::is_POD_type
is_POD	allocator/uninitialized.hpp	/^    typedef typename __type_traits<T>::is_POD_type is_POD;$/;"	t	function:ich::__uninitialized_copy	typeref:typename:__type_traits<T>::is_POD_type
is_POD_type	allocator/__type_traits.hpp	/^    typedef __false_type is_POD_type;$/;"	t	struct:ich::__type_traits	typeref:typename:__false_type	access:public
is_POD_type	allocator/__type_traits.hpp	/^    typedef __true_type is_POD_type;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
iterator	allocator/iterator.hpp	/^struct iterator {$/;"	s	namespace:ich
iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	class:deque	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	file:	access:public
iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	struct:__deque_iterator	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	file:	access:public
iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef value_type *iterator;$/;"	t	class:vector	typeref:typename:value_type *	file:	access:public
iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	access:public
iterator	contains/deque.hpp	/^    typedef __deque_iterator<T, T&, T*, BufSiz> iterator;$/;"	t	class:ich::deque	typeref:typename:__deque_iterator<T,T &,T *,BufSiz>	access:public
iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>          iter/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>          iter/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
iterator	contains/hashtable.hpp	/^    typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc> iterator;$/;"	t	class:ich::hashtable	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	access:public
iterator	contains/list.hpp	/^    typedef __list_iterator<T, T&, T*>      iterator;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T,T &,T * >	access:public
iterator	contains/list_temp.hpp	/^    typedef __list_iterator<T>       iterator;$/;"	t	class:ich::list	typeref:typename:__list_iterator<T>	access:public
iterator	contains/list_temp.hpp	/^    typedef __list_iterator<T> iterator;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T>	access:public
iterator	contains/map.hpp	/^    typedef typename rep_type::iterator                 iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::iterator	access:public
iterator	contains/multimap.hpp	/^    typedef typename rep_type::iterator                 iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::iterator	access:public
iterator	contains/multiset.hpp	/^    typedef typename rep_type::const_iterator iterator;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_iterator	access:public
iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, Value&, Value*>               iterator;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,Value &,Value * >	access:public
iterator	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_iterator<value_type,reference,pointer>	access:public
iterator	contains/set.hpp	/^    typedef typename rep_type::const_iterator iterator;$/;"	t	class:ich::set	typeref:typename:rep_type::const_iterator	access:public
iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator<T,T &,T * >	access:public
iterator	contains/slist.hpp	/^    typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,T &,T * >	access:public
iterator	contains/vector.hpp	/^    typedef value_type* iterator;$/;"	t	class:ich::vector	typeref:typename:value_type *	access:public
iterator_base	contains/slist.hpp	/^    typedef __slist_iterator_base   iterator_base;$/;"	t	class:ich::slist	typeref:typename:__slist_iterator_base	access:private
iterator_category	allocator/iterator.hpp	/^    typedef Category    iterator_category;$/;"	t	struct:ich::iterator	typeref:typename:Category	access:public
iterator_category	allocator/iterator.hpp	/^    typedef random_access_iterator_tag  iterator_category;$/;"	t	struct:ich::iterator_traits	typeref:typename:random_access_iterator_tag	access:public
iterator_category	allocator/iterator.hpp	/^    typedef typename Iterator::iterator_category    iterator_category;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::iterator_category	access:public
iterator_category	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::iterator_category iterator_category(const Iterator&) /;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::iterator_category	signature:(const Iterator &)
iterator_category	contains/deque.hpp	/^    typedef random_access_iterator_tag  iterator_category;$/;"	t	struct:ich::__deque_iterator	typeref:typename:random_access_iterator_tag	access:public
iterator_category	contains/hashtable.hpp	/^    typedef forward_iterator_tag    iterator_category;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:forward_iterator_tag	access:public
iterator_category	contains/hashtable.hpp	/^    typedef forward_iterator_tag    iterator_category;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:forward_iterator_tag	access:public
iterator_category	contains/list.hpp	/^    typedef bidirectional_iterator_tag  iterator_category;$/;"	t	struct:ich::__list_iterator	typeref:typename:bidirectional_iterator_tag	access:public
iterator_category	contains/list_temp.hpp	/^    typedef bidirectional_iterator_tag  iterator_category;$/;"	t	struct:ich::__list_iterator	typeref:typename:bidirectional_iterator_tag	access:public
iterator_category	contains/rb_tree.hpp	/^    typedef bidirectional_iterator_tag      iterator_category;$/;"	t	struct:ich::__rb_tree_base_iterator	typeref:typename:bidirectional_iterator_tag	access:public
iterator_category	contains/slist.hpp	/^    typedef forward_iterator_tag iterator_category;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:forward_iterator_tag	access:public
iterator_traits	allocator/iterator.hpp	/^struct iterator_traits {$/;"	s	namespace:ich
iterator_traits	allocator/iterator.hpp	/^struct iterator_traits<T*> {$/;"	s	namespace:ich
iterator_traits	allocator/iterator.hpp	/^struct iterator_traits<const T*> {$/;"	s	namespace:ich
iterator_traits	allocator/test.cpp	/^struct iterator_traits {$/;"	s	file:
iterator_traits	allocator/test.cpp	/^struct iterator_traits<T*> {$/;"	s	file:
iterator_traits	allocator/test.cpp	/^struct iterator_traits<const T*> {$/;"	s	file:
iterator_traits::value_type	allocator/test.cpp	/^    typedef T value_type;$/;"	t	struct:iterator_traits	typeref:typename:T	file:	access:public
iterator_traits::value_type	allocator/test.cpp	/^    typedef typename I::value_type value_type;$/;"	t	struct:iterator_traits	typeref:typename:I::value_type	file:	access:public
key	contains/rb_tree.hpp	/^    static const Key& key(base_ptr x) { return KeyOfValue()(value(x)); }$/;"	f	class:ich::rb_tree	typeref:typename:const Key &	access:protected	signature:(base_ptr x)
key	contains/rb_tree.hpp	/^    static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:ich::rb_tree	typeref:typename:const Key &	access:protected	signature:(link_type x)
key_comp	contains/map.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::map	typeref:typename:key_compare	access:public	signature:() const
key_comp	contains/multimap.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::multimap	typeref:typename:key_compare	access:public	signature:() const
key_comp	contains/multiset.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::multiset	typeref:typename:key_compare	access:public	signature:() const
key_comp	contains/rb_tree.hpp	/^    Compare key_comp() const { return key_compare; }$/;"	f	class:ich::rb_tree	typeref:typename:Compare	access:public	signature:() const
key_comp	contains/set.hpp	/^    key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:ich::set	typeref:typename:key_compare	access:public	signature:() const
key_compare	contains/map.hpp	/^    typedef Compare                 key_compare;$/;"	t	class:ich::map	typeref:typename:Compare	access:public
key_compare	contains/multimap.hpp	/^    typedef Compare                 key_compare;$/;"	t	class:ich::multimap	typeref:typename:Compare	access:public
key_compare	contains/multiset.hpp	/^    typedef Compare key_compare;$/;"	t	class:ich::multiset	typeref:typename:Compare	access:public
key_compare	contains/rb_tree.hpp	/^    Compare     key_compare;\/\/ 键值比较规则$/;"	m	class:ich::rb_tree	typeref:typename:Compare	access:protected
key_compare	contains/set.hpp	/^    typedef Compare key_compare;$/;"	t	class:ich::set	typeref:typename:Compare	access:public
key_equal	contains/hashtable.hpp	/^    typedef EqualKey key_equal;$/;"	t	class:ich::hashtable	typeref:typename:EqualKey	access:public
key_type	contains/hashtable.hpp	/^    typedef Key key_type;$/;"	t	class:ich::hashtable	typeref:typename:Key	access:public
key_type	contains/map.hpp	/^    typedef Key                     key_type;$/;"	t	class:ich::map	typeref:typename:Key	access:public
key_type	contains/multimap.hpp	/^    typedef Key                     key_type;$/;"	t	class:ich::multimap	typeref:typename:Key	access:public
key_type	contains/multiset.hpp	/^    typedef Key key_type;$/;"	t	class:ich::multiset	typeref:typename:Key	access:public
key_type	contains/rb_tree.hpp	/^    typedef Key                 key_type;$/;"	t	class:ich::rb_tree	typeref:typename:Key	access:public
key_type	contains/set.hpp	/^    typedef Key key_type;$/;"	t	class:ich::set	typeref:typename:Key	access:public
last	contains/deque.hpp	/^    T *last;$/;"	m	struct:ich::__deque_iterator	typeref:typename:T *	access:public
left	contains/rb_tree.hpp	/^     static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
left	contains/rb_tree.hpp	/^    base_ptr    left;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
left	contains/rb_tree.hpp	/^    static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
leftmost	contains/rb_tree.hpp	/^    link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
less	contains/algorithm.hpp	/^struct less$/;"	s	namespace:ich
link_type	contains/list.hpp	/^    typedef __list_node<T>* link_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_node<T> *	access:public
link_type	contains/list_temp.hpp	/^    typedef __list_node<T>*          link_type;$/;"	t	class:ich::list	typeref:typename:__list_node<T> *	access:public
link_type	contains/list_temp.hpp	/^    typedef __list_node<T>* link_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_node<T> *	access:public
link_type	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>*                                  link_type;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_node<Value> *	access:public
link_type	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:ich::__rb_tree_node	typeref:typename:__rb_tree_node<Value> *	access:public
link_type	contains/rb_tree.hpp	/^    typedef rb_tree_node*       link_type;$/;"	t	class:ich::rb_tree	typeref:typename:rb_tree_node *	access:public
list	contains/list_temp.hpp	/^    list() { empty_initialize(); }$/;"	f	class:ich::list	access:public	signature:()
list	contains/list_temp.hpp	/^class list {$/;"	c	namespace:ich
list_node	contains/list_temp.hpp	/^    typedef __list_node<T>          list_node;$/;"	t	class:ich::list	typeref:typename:__list_node<T>	access:protected
list_node	contains/slist.hpp	/^    typedef __slist_node<T>         list_node;$/;"	t	class:ich::slist	typeref:typename:__slist_node<T>	access:private
list_node	contains/slist.hpp	/^    typedef __slist_node<T> list_node;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_node<T>	access:public
list_node_allocator	contains/list_temp.hpp	/^    typedef Alloc                   list_node_allocator;$/;"	t	class:ich::list	typeref:typename:Alloc	access:protected
list_node_allocator	contains/slist.hpp	/^    typedef allocator<list_node>    list_node_allocator;$/;"	t	class:ich::slist	typeref:typename:allocator<list_node>	access:private
list_node_base	contains/slist.hpp	/^    typedef __slist_node_base       list_node_base;$/;"	t	class:ich::slist	typeref:typename:__slist_node_base	access:private
list_test	contains/test.cpp	/^void list_test() {$/;"	f	typeref:typename:void	signature:()
lower_bound	contains/algorithm.hpp	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T &value) /;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value)
lower_bound	contains/algorithm.hpp	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T &value, /;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,ForwardIterator last,const T & value,Compare comp)
lower_bound	contains/map.hpp	/^    const_iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
lower_bound	contains/map.hpp	/^    iterator lower_bound(const key_type &x) { return t.lower_bound(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
lower_bound	contains/multimap.hpp	/^    const_iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
lower_bound	contains/multimap.hpp	/^    iterator lower_bound(const key_type &x) { return t.lower_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
lower_bound	contains/multiset.hpp	/^    iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
lower_bound	contains/rb_tree.hpp	/^    const_iterator lower_bound(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:(const Key & k) const
lower_bound	contains/rb_tree.hpp	/^    iterator lower_bound(const Key &k);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k)
lower_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::const_iterator	signature:(const Key & k) const
lower_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key &k) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k)
lower_bound	contains/set.hpp	/^    iterator lower_bound(const key_type &x) const { return t.lower_bound(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
m_i	confusing_syntax/indecrement_operator_overloading.cpp	/^    int m_i;$/;"	m	class:INT	typeref:typename:int	file:	access:private
main	allocator/test.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
main	confusing_syntax/function_ret.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
main	confusing_syntax/indecrement_operator_overloading.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
main	confusing_syntax/some_confusing_syntax.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
main	contains/test.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
main	contains/what.cpp	/^int main()$/;"	f	typeref:typename:int	signature:()
make_heap	contains/algorithm.hpp	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
make_heap	contains/algorithm.hpp	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
make_pair	contains/pair.hpp	/^inline pair<T1, T2> make_pair(const T1 &_x, const T2 &_y) {$/;"	f	namespace:ich	typeref:typename:pair<T1,T2>	signature:(const T1 & _x,const T2 & _y)
malloc_alloc	allocator/alloc.hpp	/^#define malloc_alloc /;"	d
malloc_alloc	allocator/alloc.hpp	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t	namespace:ich	typeref:typename:__malloc_alloc_template<0>
map	contains/deque.hpp	/^    map_pointer map;    \/\/ map是连续空间，每个元素都是指针，指向缓冲区$/;"	m	class:ich::deque	typeref:typename:map_pointer	access:protected
map	contains/map.hpp	/^    explicit map(const Compare &comp) : t(comp) {}$/;"	f	class:ich::map	access:public	signature:(const Compare & comp)
map	contains/map.hpp	/^    map() : t(Compare()) {}$/;"	f	class:ich::map	access:public	signature:()
map	contains/map.hpp	/^    map(InputIterator first, InputIterator last) : t(Compare()) { t.insert_unique(first, last); /;"	f	class:ich::map	access:public	signature:(InputIterator first,InputIterator last)
map	contains/map.hpp	/^    map(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_uniqu/;"	f	class:ich::map	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
map	contains/map.hpp	/^    map(const map<Key, T, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::map	access:public	signature:(const map<Key,T,Compare,Alloc> & x)
map	contains/map.hpp	/^class map$/;"	c	namespace:ich
map_allocator	contains/deque.hpp	/^    typedef allocator<pointer>      map_allocator;$/;"	t	class:ich::deque	typeref:typename:allocator<pointer>	access:protected
map_n_multimap_test	contains/test.cpp	/^void map_n_multimap_test() {$/;"	f	typeref:typename:void	signature:()
map_pointer	contains/deque.hpp	/^    typedef pointer*            map_pointer;$/;"	t	struct:ich::__deque_iterator	typeref:typename:pointer *	access:public
map_pointer	contains/deque.hpp	/^    typedef pointer*    map_pointer;$/;"	t	class:ich::deque	typeref:typename:pointer *	access:protected
map_size	contains/deque.hpp	/^    size_type map_size; \/\/ map可容纳多少指针$/;"	m	class:ich::deque	typeref:typename:size_type	access:protected
mapped_type	contains/map.hpp	/^    typedef T                       mapped_type;$/;"	t	class:ich::map	typeref:typename:T	access:public
max	contains/algorithm.hpp	/^T max(const T &left, const T &right) {$/;"	f	namespace:ich	typeref:typename:T	signature:(const T & left,const T & right)
max_bucket_count	contains/hashtable.hpp	/^    size_type max_bucket_count() const { return __stl_prime_list[__stl_num_primes - 1]; }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
max_size	allocator/jj_allocator.hpp	/^    size_type max_size() const$/;"	f	class:JJ::allocator	typeref:typename:size_type	access:public	signature:() const
max_size	allocator/std_allocator.hpp	/^    size_type max_size() {$/;"	f	class:allocator	typeref:typename:size_type	access:public	signature:()
max_size	contains/deque.hpp	/^    size_type max_size() const { return size_type(-1); }$/;"	f	class:ich::deque	typeref:typename:size_type	access:public	signature:() const
max_size	contains/map.hpp	/^    size_type max_size() const { return t.size(); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:() const
max_size	contains/multimap.hpp	/^    size_type max_size() const { return t.size(); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:() const
max_size	contains/multiset.hpp	/^    size_type max_size() const { return t.max_size(); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:() const
max_size	contains/rb_tree.hpp	/^    size_type max_size() const { return size_type(-1); }$/;"	f	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:() const
max_size	contains/set.hpp	/^    size_type max_size() const { return t.max_size(); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:() const
maximum	contains/rb_tree.hpp	/^    static base_ptr maximum(base_ptr x) { while (x->right != 0) x = x->right; return x; }$/;"	f	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public	signature:(base_ptr x)
maximum	contains/rb_tree.hpp	/^    static link_type maximum(link_type x) { return (link_type) __rb_tree_node_base::maximum(x); /;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
minimum	contains/rb_tree.hpp	/^    static base_ptr minimum(base_ptr x) { while (x->left != 0) x = x->left; return x; }$/;"	f	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public	signature:(base_ptr x)
minimum	contains/rb_tree.hpp	/^    static link_type minimum(link_type x) { return (link_type) __rb_tree_node_base::minimum(x); /;"	f	class:ich::rb_tree	typeref:typename:link_type	access:protected	signature:(link_type x)
multimap	contains/multimap.hpp	/^    explicit multimap(const Compare &comp) : t(comp) {}$/;"	f	class:ich::multimap	access:public	signature:(const Compare & comp)
multimap	contains/multimap.hpp	/^    multimap() : t(Compare()) {}$/;"	f	class:ich::multimap	access:public	signature:()
multimap	contains/multimap.hpp	/^    multimap(InputIterator first, InputIterator last) : t(Compare()) { t.insert_equal(first, las/;"	f	class:ich::multimap	access:public	signature:(InputIterator first,InputIterator last)
multimap	contains/multimap.hpp	/^    multimap(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_/;"	f	class:ich::multimap	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
multimap	contains/multimap.hpp	/^    multimap(const multimap<Key, T, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::multimap	access:public	signature:(const multimap<Key,T,Compare,Alloc> & x)
multimap	contains/multimap.hpp	/^class multimap$/;"	c	namespace:ich
multimapped_type	contains/multimap.hpp	/^    typedef T                       multimapped_type;$/;"	t	class:ich::multimap	typeref:typename:T	access:public
multiset	contains/multiset.hpp	/^    explicit multiset(const Compare &comp) : t(comp) {}$/;"	f	class:ich::multiset	access:public	signature:(const Compare & comp)
multiset	contains/multiset.hpp	/^    multiset() : t(Compare()) {}$/;"	f	class:ich::multiset	access:public	signature:()
multiset	contains/multiset.hpp	/^    multiset(InputIterator first, InputIterator last) : t(Compare()) { t.insert_equal(first, las/;"	f	class:ich::multiset	access:public	signature:(InputIterator first,InputIterator last)
multiset	contains/multiset.hpp	/^    multiset(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_/;"	f	class:ich::multiset	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
multiset	contains/multiset.hpp	/^    multiset(const multiset<Key, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::multiset	access:public	signature:(const multiset<Key,Compare,Alloc> & x)
multiset	contains/multiset.hpp	/^class multiset {$/;"	c	namespace:ich
multiset_test	contains/test.cpp	/^void multiset_test() {$/;"	f	typeref:typename:void	signature:()
new_node	contains/hashtable.hpp	/^    node* new_node(const value_type &obj) {$/;"	f	class:ich::hashtable	typeref:typename:node *	access:public	signature:(const value_type & obj)
next	contains/hashtable.hpp	/^    __hashtable_node *next;$/;"	m	struct:ich::__hashtable_node	typeref:typename:__hashtable_node *	access:public
next	contains/list.hpp	/^    void_pointer next;$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
next	contains/list_temp.hpp	/^    void_pointer next;$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
next	contains/slist.hpp	/^    __slist_node_base *next;$/;"	m	struct:ich::__slist_node_base	typeref:typename:__slist_node_base *	access:public
next_size	contains/hashtable.hpp	/^    size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:(size_type n) const
node	contains/deque.hpp	/^    map_pointer node;$/;"	m	struct:ich::__deque_iterator	typeref:typename:map_pointer	access:public
node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	class:ich::hashtable	typeref:typename:__hashtable_node<Value>	access:private
node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:__hashtable_node<Value>	access:public
node	contains/hashtable.hpp	/^    typedef __hashtable_node<Value> node;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:__hashtable_node<Value>	access:public
node	contains/list.hpp	/^    link_type node;$/;"	m	struct:ich::__list_iterator	typeref:typename:link_type	access:public
node	contains/list_temp.hpp	/^    link_type node; \/\/ 只需要一个指针，就能实现环状双向链表$/;"	m	class:ich::list	typeref:typename:link_type	access:protected
node	contains/list_temp.hpp	/^    link_type node;$/;"	m	struct:ich::__list_iterator	typeref:typename:link_type	access:public
node	contains/rb_tree.hpp	/^    base_ptr node;$/;"	m	struct:ich::__rb_tree_base_iterator	typeref:typename:base_ptr	access:public
node	contains/slist.hpp	/^    __slist_node_base *node;$/;"	m	struct:ich::__slist_iterator_base	typeref:typename:__slist_node_base *	access:public
node_allocator	contains/hashtable.hpp	/^    typedef allocator<node>         node_allocator;$/;"	t	class:ich::hashtable	typeref:typename:allocator<node>	access:private
node_count	contains/rb_tree.hpp	/^    size_type   node_count; \/\/ 节点数量$/;"	m	class:ich::rb_tree	typeref:typename:size_type	access:protected
none	allocator/test.cpp	/^void none()$/;"	f	typeref:typename:void	signature:()
num_elements	contains/hashtable.hpp	/^    size_type                       num_elements;$/;"	m	class:ich::hashtable	typeref:typename:size_type	access:private
obj	allocator/alloc.hpp	/^    union obj {$/;"	u	class:ich::__default_alloc_template	access:private
oom_malloc	allocator/alloc.hpp	/^    static void *oom_malloc(size_t);$/;"	p	class:ich::__malloc_alloc_template	typeref:typename:void *	access:private	signature:(size_t)
oom_malloc	allocator/alloc.hpp	/^void* __malloc_alloc_template<inst>::oom_malloc(size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	signature:(size_t n)
oom_realloc	allocator/alloc.hpp	/^    static void *oom_realloc(void *, size_t);$/;"	p	class:ich::__malloc_alloc_template	typeref:typename:void *	access:private	signature:(void *,size_t)
oom_realloc	allocator/alloc.hpp	/^void* __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	signature:(void * p,size_t n)
operator !=	contains/deque.hpp	/^    bool operator!=(const self &x) const { return !(*this == x); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator !=	contains/hashtable.hpp	/^    bool operator!=(const iterator &it) const { return cur != it.cur; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
operator !=	contains/hashtable.hpp	/^    bool operator!=(const iterator &it) const { return cur != it.cur; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
operator !=	contains/list.hpp	/^    bool operator!=(const self &x) const { return node != x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator !=	contains/list_temp.hpp	/^    bool operator!=(const self &x) const { return node != x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator !=	contains/pair.hpp	/^inline bool operator!=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator !=	contains/rb_tree.hpp	/^    bool operator!=(const self &x) { return !(*this == x); }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:bool	access:public	signature:(const self & x)
operator !=	contains/slist.hpp	/^    bool operator!=(const __slist_iterator_base &x) const { return node != x.node; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:bool	access:public	signature:(const __slist_iterator_base & x) const
operator ()	confusing_syntax/some_confusing_syntax.cpp	/^    void operator()(const T &elem)$/;"	f	class:print	typeref:typename:void	file:	access:public	signature:(const T & elem)
operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs < rhs; }$/;"	f	struct:ich::less	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs == rhs; }$/;"	f	struct:ich::equal_to	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
operator ()	contains/algorithm.hpp	/^    bool operator()(const T &lhs, const T &rhs) const { return lhs > rhs; }$/;"	f	struct:ich::greater	typeref:typename:bool	access:public	signature:(const T & lhs,const T & rhs) const
operator ()	contains/algorithm.hpp	/^    const T& operator()(const T &x) const { return x; }$/;"	f	struct:ich::identity	typeref:typename:const T &	access:public	signature:(const T & x) const
operator ()	contains/algorithm.hpp	/^    const T&& operator()(const T &&x) const { return x; }$/;"	f	struct:ich::identity	typeref:typename:const T &&	access:public	signature:(const T && x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(char x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(const char *s) const { return __stl_hash_string(s); }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(const char * s) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(int x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(int x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(long long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(long long x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(long x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(short x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(short x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(signed char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(signed char x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned char x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned int x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned long long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned long long x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned long x) const
operator ()	contains/hash_fun.hpp	/^    size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:ich::hash	typeref:typename:size_t	access:public	signature:(unsigned short x) const
operator () 	contains/map.hpp	/^        bool operator() (const value_type &x, const value_type &y) const { return comp(x.first, /;"	f	class:ich::map::value_compare	typeref:typename:bool	access:public	signature:(const value_type & x,const value_type & y) const
operator () 	contains/multimap.hpp	/^        bool operator() (const value_type &x, const value_type &y) const { return comp(x.first, /;"	f	class:ich::multimap::value_compare	typeref:typename:bool	access:public	signature:(const value_type & x,const value_type & y) const
operator *	allocator/test.cpp	/^    T& operator*() { return *ptr; }$/;"	f	struct:MyIter	typeref:typename:T &	file:	access:public	signature:()
operator *	confusing_syntax/indecrement_operator_overloading.cpp	/^    int& operator*() const$/;"	f	class:INT	typeref:typename:int &	file:	access:public	signature:() const
operator *	contains/deque.hpp	/^    reference operator*() const { return *cur; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/hashtable.hpp	/^    reference operator*() const { return cur->val; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/hashtable.hpp	/^    reference operator*() const { return cur->val; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/list.hpp	/^    reference operator*() const { return (*node).data; }$/;"	f	struct:ich::__list_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/list_temp.hpp	/^    reference operator*() const { return (*node).data; }$/;"	f	struct:ich::__list_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/rb_tree.hpp	/^    reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:reference	access:public	signature:() const
operator *	contains/slist.hpp	/^    reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:ich::__slist_iterator	typeref:typename:reference	access:public	signature:() const
operator +	contains/deque.hpp	/^    self operator+(difference_type n) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(difference_type n) const
operator ++	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT& operator++()           \/\/ ++INT$/;"	f	class:INT	typeref:typename:INT &	file:	access:public	signature:()
operator ++	confusing_syntax/indecrement_operator_overloading.cpp	/^    const INT operator++(int)   \/\/ INT++$/;"	f	class:INT	typeref:typename:const INT	file:	access:public	signature:(int)
operator ++	contains/deque.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(int)
operator ++	contains/deque.hpp	/^    self& operator++() {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:()
operator ++	contains/hashtable.hpp	/^    const_iterator operator++(int);$/;"	p	struct:ich::__hashtable_const_iterator	typeref:typename:const_iterator	access:public	signature:(int)
operator ++	contains/hashtable.hpp	/^    const_iterator& operator++();$/;"	p	struct:ich::__hashtable_const_iterator	typeref:typename:const_iterator &	access:public	signature:()
operator ++	contains/hashtable.hpp	/^    iterator operator++(int);$/;"	p	struct:ich::__hashtable_iterator	typeref:typename:iterator	access:public	signature:(int)
operator ++	contains/hashtable.hpp	/^    iterator& operator++();$/;"	p	struct:ich::__hashtable_iterator	typeref:typename:iterator &	access:public	signature:()
operator ++	contains/hashtable.hpp	/^__hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++() {$/;"	f	class:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc> &	signature:()
operator ++	contains/hashtable.hpp	/^__hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++(int) {$/;"	f	class:ich::__hashtable_const_iterator	typeref:typename:__hashtable_const_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	signature:(int)
operator ++	contains/hashtable.hpp	/^__hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++() {$/;"	f	class:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc> &	signature:()
operator ++	contains/hashtable.hpp	/^__hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::operator++(int) {$/;"	f	class:ich::__hashtable_iterator	typeref:typename:__hashtable_iterator<Value,Key,HashFcn,ExtractKey,EqualKey,Alloc>	signature:(int)
operator ++	contains/list.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self	access:public	signature:(int)
operator ++	contains/list.hpp	/^    self& operator++() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
operator ++	contains/list_temp.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self	access:public	signature:(int)
operator ++	contains/list_temp.hpp	/^    self& operator++() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
operator ++	contains/rb_tree.hpp	/^    self operator++(int) {$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self	access:public	signature:(int)
operator ++	contains/rb_tree.hpp	/^    self& operator++() { increment(); return *this; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self &	access:public	signature:()
operator ++	contains/slist.hpp	/^    self& operator++() {$/;"	f	struct:ich::__slist_iterator	typeref:typename:self &	access:public	signature:()
operator ++	contains/slist.hpp	/^    self& operator++(int) {$/;"	f	struct:ich::__slist_iterator	typeref:typename:self &	access:public	signature:(int)
operator +=	contains/deque.hpp	/^    self& operator+=(difference_type n) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:(difference_type n)
operator -	contains/deque.hpp	/^    difference_type operator-(const self &x) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:difference_type	access:public	signature:(const self & x) const
operator -	contains/deque.hpp	/^    self operator-(difference_type n) const {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(difference_type n) const
operator --	confusing_syntax/indecrement_operator_overloading.cpp	/^    INT& operator--()           \/\/ --INT$/;"	f	class:INT	typeref:typename:INT &	file:	access:public	signature:()
operator --	confusing_syntax/indecrement_operator_overloading.cpp	/^    const INT operator--(int)   \/\/ INT--$/;"	f	class:INT	typeref:typename:const INT	file:	access:public	signature:(int)
operator --	contains/deque.hpp	/^    self operator--(int) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self	access:public	signature:(int)
operator --	contains/deque.hpp	/^    self& operator--() {$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:()
operator --	contains/list.hpp	/^    self& operator--() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
operator --	contains/list.hpp	/^    self& operator--(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:(int)
operator --	contains/list_temp.hpp	/^    self& operator--() {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:()
operator --	contains/list_temp.hpp	/^    self& operator--(int) {$/;"	f	struct:ich::__list_iterator	typeref:typename:self &	access:public	signature:(int)
operator --	contains/rb_tree.hpp	/^    self operator--(int) {$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self	access:public	signature:(int)
operator --	contains/rb_tree.hpp	/^    self& operator--() { decrement(); return *this; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:self &	access:public	signature:()
operator -=	contains/deque.hpp	/^    self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:self &	access:public	signature:(difference_type n)
operator ->	contains/deque.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/hashtable.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/hashtable.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/list.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__list_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/list_temp.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__list_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/rb_tree.hpp	/^    pointer operator->() const { return &(operator*()); }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:pointer	access:public	signature:() const
operator ->	contains/slist.hpp	/^    reference operator->() const { return &(operator*()); }$/;"	f	struct:ich::__slist_iterator	typeref:typename:reference	access:public	signature:() const
operator <	confusing_syntax/some_confusing_syntax.cpp	/^bool operator<(const stack<T, Sequence> &x, const stack<T, Sequence> &y)$/;"	f	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator <	confusing_syntax/some_confusing_syntax.cpp	/^bool operator<(const stack<T, Sequence> &x, const stack<T, Sequence> &y);$/;"	p	typeref:typename:bool	file:	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator <	contains/deque.hpp	/^    bool operator<(const self &x) const { return (node == x.node) ? (cur < x.cur) : (node < x.no/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator <	contains/multiset.hpp	/^inline bool operator<(const multiset<Key, Compare, Alloc> &x, const multiset<Key, Compare, Alloc/;"	f	namespace:ich	typeref:typename:bool	signature:(const multiset<Key,Compare,Alloc> & x,const multiset<Key,Compare,Alloc> & y)
operator <	contains/pair.hpp	/^inline bool operator<(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator <	contains/queue.hpp	/^inline bool operator<(const queue<T, Sequence> &x, const queue<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const queue<T,Sequence> & x,const queue<T,Sequence> & y)
operator <	contains/set.hpp	/^inline bool operator<(const set<Key, Compare, Alloc> &x, const set<Key, Compare, Alloc> &y) { re/;"	f	namespace:ich	typeref:typename:bool	signature:(const set<Key,Compare,Alloc> & x,const set<Key,Compare,Alloc> & y)
operator <	contains/stack.hpp	/^inline bool operator<(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator <<	confusing_syntax/indecrement_operator_overloading.cpp	/^std::ostream& operator<<(std::ostream &os, const INT &i)$/;"	f	typeref:typename:std::ostream &	signature:(std::ostream & os,const INT & i)
operator <=	contains/pair.hpp	/^inline bool operator<=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator =	contains/multiset.hpp	/^    multiset<Key, Compare, Alloc>& operator=(const multiset<Key, Compare, Alloc> &x) { t = x.t; /;"	f	class:ich::multiset	typeref:typename:multiset<Key,Compare,Alloc> &	access:public	signature:(const multiset<Key,Compare,Alloc> & x)
operator =	contains/rb_tree.hpp	/^        operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc> &x);$/;"	p	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc> &	access:public	signature:(const rb_tree<Key,Value,KeyOfValue,Compare,Alloc> & x)
operator =	contains/set.hpp	/^    set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc> &x) { t = x.t; return *th/;"	f	class:ich::set	typeref:typename:set<Key,Compare,Alloc> &	access:public	signature:(const set<Key,Compare,Alloc> & x)
operator ==	confusing_syntax/some_confusing_syntax.cpp	/^bool operator==(const stack<T, Sequence> &x, const stack<T, Sequence> &y)$/;"	f	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator ==	confusing_syntax/some_confusing_syntax.cpp	/^bool operator==(const stack<T, Sequence> &x, const stack<T, Sequence> &y);$/;"	p	typeref:typename:bool	file:	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator ==	contains/deque.hpp	/^    bool operator==(const self &x) const { return cur == x.cur; }$/;"	f	struct:ich::__deque_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator ==	contains/hashtable.hpp	/^    bool operator==(const iterator &it) const { return cur == it.cur; }$/;"	f	struct:ich::__hashtable_const_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
operator ==	contains/hashtable.hpp	/^    bool operator==(const iterator &it) const { return cur == it.cur; }$/;"	f	struct:ich::__hashtable_iterator	typeref:typename:bool	access:public	signature:(const iterator & it) const
operator ==	contains/list.hpp	/^    bool operator==(const self &x) const { return node == x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator ==	contains/list_temp.hpp	/^    bool operator==(const self &x) const { return node == x.node; }$/;"	f	struct:ich::__list_iterator	typeref:typename:bool	access:public	signature:(const self & x) const
operator ==	contains/map.hpp	/^inline bool operator==(const map<Key, T, Compare, Alloc> &x, const map<Key, T, Compare, Alloc> &/;"	f	namespace:ich	typeref:typename:bool	signature:(const map<Key,T,Compare,Alloc> & x,const map<Key,T,Compare,Alloc> & y)
operator ==	contains/multimap.hpp	/^inline bool operator==(const multimap<Key, T, Compare, Alloc> &x, const multimap<Key, T, Compare/;"	f	namespace:ich	typeref:typename:bool	signature:(const multimap<Key,T,Compare,Alloc> & x,const multimap<Key,T,Compare,Alloc> & y)
operator ==	contains/multiset.hpp	/^inline bool operator==(const multiset<Key, Compare, Alloc> &x, const multiset<Key, Compare, Allo/;"	f	namespace:ich	typeref:typename:bool	signature:(const multiset<Key,Compare,Alloc> & x,const multiset<Key,Compare,Alloc> & y)
operator ==	contains/pair.hpp	/^inline bool operator==(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator ==	contains/queue.hpp	/^inline bool operator==(const queue<T, Sequence> &x, const queue<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const queue<T,Sequence> & x,const queue<T,Sequence> & y)
operator ==	contains/rb_tree.hpp	/^    bool operator==(const self &x) { return node == x.node; }$/;"	f	struct:ich::__rb_tree_iterator	typeref:typename:bool	access:public	signature:(const self & x)
operator ==	contains/set.hpp	/^inline bool operator==(const set<Key, Compare, Alloc> &x, const set<Key, Compare, Alloc> &y) { r/;"	f	namespace:ich	typeref:typename:bool	signature:(const set<Key,Compare,Alloc> & x,const set<Key,Compare,Alloc> & y)
operator ==	contains/slist.hpp	/^    bool operator==(const __slist_iterator_base &x) const { return node == x.node; }$/;"	f	struct:ich::__slist_iterator_base	typeref:typename:bool	access:public	signature:(const __slist_iterator_base & x) const
operator ==	contains/stack.hpp	/^inline bool operator==(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const stack<T,Sequence> & x,const stack<T,Sequence> & y)
operator >	contains/pair.hpp	/^inline bool operator>(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator >=	contains/pair.hpp	/^inline bool operator>=(const pair<T1, T2> &_x, const pair<T1, T2> &_y) {$/;"	f	namespace:ich	typeref:typename:bool	signature:(const pair<T1,T2> & _x,const pair<T1,T2> & _y)
operator []	contains/deque.hpp	/^    reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:ich::__deque_iterator	typeref:typename:reference	access:public	signature:(difference_type n) const
operator []	contains/deque.hpp	/^    reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:ich::deque	typeref:typename:reference	access:public	signature:(size_type n)
operator []	contains/map.hpp	/^    t& operator[](const key_type &k) { return (*((insert(value_type(k, T()))).first)).second; } /;"	f	class:ich::map	typeref:typename:t &	access:public	signature:(const key_type & k)
operator []	contains/multimap.hpp	/^    t& operator[](const key_type &k) { return (*((insert(value_type(k, T()))).first)).second; } /;"	f	class:ich::multimap	typeref:typename:t &	access:public	signature:(const key_type & k)
operator [] 	contains/vector.hpp	/^    const_reference operator[] (size_type n) const { return *(cbegin() + n); }$/;"	f	class:ich::vector	typeref:typename:const_reference	access:public	signature:(size_type n) const
operator [] 	contains/vector.hpp	/^    reference operator[] (size_type n) { return *(begin() + n); }$/;"	f	class:ich::vector	typeref:typename:reference	access:public	signature:(size_type n)
other	allocator/jj_allocator.hpp	/^        typedef allocator<U> other;$/;"	t	struct:JJ::allocator::rebind	typeref:typename:allocator<U>	access:public
output_iterator_tag	allocator/iterator.hpp	/^struct output_iterator_tag {};$/;"	s	namespace:ich
pair	contains/pair.hpp	/^    pair() : first(T1()), second(T2()) {}$/;"	f	struct:ich::pair	access:public	signature:()
pair	contains/pair.hpp	/^    pair(const T1 &_x, const T2 &_y) : first(_x), second(_y) {}$/;"	f	struct:ich::pair	access:public	signature:(const T1 & _x,const T2 & _y)
pair	contains/pair.hpp	/^struct pair$/;"	s	namespace:ich
pair_iterator_bool	contains/multiset.hpp	/^    typedef pair<iterator, bool> pair_iterator_bool;$/;"	t	class:ich::multiset	typeref:typename:pair<iterator,bool>	access:public
pair_iterator_bool	contains/set.hpp	/^    typedef pair<iterator, bool> pair_iterator_bool;$/;"	t	class:ich::set	typeref:typename:pair<iterator,bool>	access:public
parent	contains/rb_tree.hpp	/^    base_ptr    parent;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
parent	contains/rb_tree.hpp	/^    static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
parent	contains/rb_tree.hpp	/^    static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
pointer	allocator/allocator.hpp	/^    typedef T*              pointer;$/;"	t	class:ich::allocator	typeref:typename:T *	access:public
pointer	allocator/iterator.hpp	/^    typedef Pointer     pointer;$/;"	t	struct:ich::iterator	typeref:typename:Pointer	access:public
pointer	allocator/iterator.hpp	/^    typedef T*                          pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:T *	access:public
pointer	allocator/iterator.hpp	/^    typedef const T*                    pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:const T *	access:public
pointer	allocator/iterator.hpp	/^    typedef typename Iterator::pointer              pointer;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::pointer	access:public
pointer	allocator/jj_allocator.hpp	/^    typedef T*              pointer;$/;"	t	class:JJ::allocator	typeref:typename:T *	access:public
pointer	allocator/std_allocator.hpp	/^    typedef T* pointer;$/;"	t	class:allocator	typeref:typename:T *	access:public
pointer	allocator/std_allocator.hpp	/^    typedef void *pointer;$/;"	t	class:allocator	typeref:typename:void *	access:public
pointer	contains/deque.hpp	/^    typedef Ptr                 pointer;$/;"	t	struct:ich::__deque_iterator	typeref:typename:Ptr	access:public
pointer	contains/deque.hpp	/^    typedef T*          pointer;$/;"	t	class:ich::deque	typeref:typename:T *	access:public
pointer	contains/hashtable.hpp	/^    typedef Value*                  pointer;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value *	access:public
pointer	contains/hashtable.hpp	/^    typedef const Value*                  pointer;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:const Value *	access:public
pointer	contains/hashtable.hpp	/^    typedef value_type* pointer;$/;"	t	class:ich::hashtable	typeref:typename:value_type *	access:public
pointer	contains/list.hpp	/^    typedef Ptr             pointer;$/;"	t	struct:ich::__list_iterator	typeref:typename:Ptr	access:public
pointer	contains/list_temp.hpp	/^    typedef T*              pointer;$/;"	t	struct:ich::__list_iterator	typeref:typename:T *	access:public
pointer	contains/map.hpp	/^    typedef typename rep_type::pointer                  pointer;$/;"	t	class:ich::map	typeref:typename:rep_type::pointer	access:public
pointer	contains/multimap.hpp	/^    typedef typename rep_type::pointer                  pointer;$/;"	t	class:ich::multimap	typeref:typename:rep_type::pointer	access:public
pointer	contains/multiset.hpp	/^    typedef typename rep_type::const_pointer pointer;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_pointer	access:public
pointer	contains/rb_tree.hpp	/^    typedef Ptr     pointer;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Ptr	access:public
pointer	contains/rb_tree.hpp	/^    typedef value_type*         pointer;$/;"	t	class:ich::rb_tree	typeref:typename:value_type *	access:public
pointer	contains/set.hpp	/^    typedef typename rep_type::const_pointer pointer;$/;"	t	class:ich::set	typeref:typename:rep_type::const_pointer	access:public
pointer	contains/slist.hpp	/^    typedef Ptr             pointer;$/;"	t	struct:ich::__slist_iterator	typeref:typename:Ptr	access:public
pointer	contains/slist.hpp	/^    typedef value_type*         pointer;$/;"	t	class:ich::slist	typeref:typename:value_type *	access:public
pointer	contains/vector.hpp	/^    typedef value_type* pointer;$/;"	t	class:ich::vector	typeref:typename:value_type *	access:public
pop	contains/queue.hpp	/^    void pop() { c.pop_front(); }$/;"	f	class:ich::queue	typeref:typename:void	access:public	signature:()
pop	contains/stack.hpp	/^    void pop() { c.pop_back(); }$/;"	f	class:ich::stack	typeref:typename:void	access:public	signature:()
pop_back	contains/deque.hpp	/^    void pop_back() {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:()
pop_back	contains/list_temp.hpp	/^    void pop_back() { iterator tmp = end(); erase(--tmp); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
pop_back	contains/vector.hpp	/^    void pop_back() {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:()
pop_back_aux	contains/deque.hpp	/^    void pop_back_aux();$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:()
pop_back_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::pop_back_aux() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
pop_front	contains/deque.hpp	/^    void pop_front() {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:()
pop_front	contains/list_temp.hpp	/^    void pop_front() { erase(begin()); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
pop_front	contains/slist.hpp	/^    void pop_front() {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:()
pop_front_aux	contains/deque.hpp	/^    void pop_front_aux();$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:()
pop_front_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:ich::deque	typeref:typename:void	signature:()
pop_heap	contains/algorithm.hpp	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
pop_heap	contains/algorithm.hpp	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
prev	contains/list.hpp	/^    void_pointer prev;  \/\/ __list_node<T>*$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
prev	contains/list_temp.hpp	/^    void_pointer prev;  \/\/ __list_node<T>*$/;"	m	struct:ich::__list_node	typeref:typename:void_pointer	access:public
print	confusing_syntax/some_confusing_syntax.cpp	/^class print$/;"	c	file:
print::operator ()	confusing_syntax/some_confusing_syntax.cpp	/^    void operator()(const T &elem)$/;"	f	class:print	typeref:typename:void	file:	access:public	signature:(const T & elem)
priority_queue_test	contains/test.cpp	/^void priority_queue_test() {$/;"	f	typeref:typename:void	signature:()
ptr	allocator/test.cpp	/^    T *ptr;$/;"	m	struct:MyIter	typeref:typename:T *	file:	access:public
push	contains/queue.hpp	/^    void push(const value_type &x) { c.push_back(x); }$/;"	f	class:ich::queue	typeref:typename:void	access:public	signature:(const value_type & x)
push	contains/stack.hpp	/^    void push(const value_type &x) { c.push_back(x); }$/;"	f	class:ich::stack	typeref:typename:void	access:public	signature:(const value_type & x)
push_back	contains/deque.hpp	/^    void push_back(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:(const value_type & t)
push_back	contains/list_temp.hpp	/^    void push_back(const T &x) { insert(end(), x); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & x)
push_back	contains/vector.hpp	/^    void push_back(const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(const T & x)
push_back_aux	contains/deque.hpp	/^    void push_back_aux(const value_type &t);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(const value_type & t)
push_back_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(const value_type & t)
push_front	contains/deque.hpp	/^    void push_front(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	access:public	signature:(const value_type & t)
push_front	contains/list_temp.hpp	/^    void push_front(const T &x) { insert(begin(), x); }$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & x)
push_front	contains/slist.hpp	/^    void push_front(const value_type &x) { __slist_make_link(&head, create_node(x)); }$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(const value_type & x)
push_front_aux	contains/deque.hpp	/^    void push_front_aux(const value_type &t);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(const value_type & t)
push_front_aux	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type &t) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(const value_type & t)
push_heap	contains/algorithm.hpp	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
push_heap	contains/algorithm.hpp	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last,Compare comp)
put_node	contains/list_temp.hpp	/^    void put_node(link_type p) { list_node_allocator::deallocate((T*)p); }$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(link_type p)
put_node	contains/rb_tree.hpp	/^    void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:ich::rb_tree	typeref:typename:void	access:protected	signature:(link_type p)
queue	contains/queue.hpp	/^class queue {$/;"	c	namespace:ich
queue_test	contains/test.cpp	/^void queue_test() {$/;"	f	typeref:typename:void	signature:()
random_access_iterator_tag	allocator/iterator.hpp	/^struct random_access_iterator_tag : public bidirectional_iterator_tag {};$/;"	s	namespace:ich	inherits:bidirectional_iterator_tag
rb_tree	contains/rb_tree.hpp	/^    rb_tree(const Compare &comp = Compare()) : node_count(0), key_compare(comp) { init(); }$/;"	f	class:ich::rb_tree	access:public	signature:(const Compare & comp=Compare ())
rb_tree	contains/rb_tree.hpp	/^class rb_tree$/;"	c	namespace:ich
rb_tree_node	contains/rb_tree.hpp	/^    typedef __rb_tree_node<Value>   rb_tree_node;$/;"	t	class:ich::rb_tree	typeref:typename:__rb_tree_node<Value>	access:protected
rb_tree_node_allocator	contains/rb_tree.hpp	/^    typedef allocator<rb_tree_node> rb_tree_node_allocator;$/;"	t	class:ich::rb_tree	typeref:typename:allocator<rb_tree_node>	access:protected
rb_tree_test	contains/test.cpp	/^void rb_tree_test() {$/;"	f	typeref:typename:void	signature:()
rbegin	contains/map.hpp	/^    const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:ich::map	typeref:typename:const_reverse_iterator	access:public	signature:() const
rbegin	contains/map.hpp	/^    reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:ich::map	typeref:typename:reverse_iterator	access:public	signature:()
rbegin	contains/multimap.hpp	/^    const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:ich::multimap	typeref:typename:const_reverse_iterator	access:public	signature:() const
rbegin	contains/multimap.hpp	/^    reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:ich::multimap	typeref:typename:reverse_iterator	access:public	signature:()
reallocate	allocator/alloc.hpp	/^    static void* reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz) {$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void *	access:public	signature:(void * p,size_t,size_t new_sz)
reallocate	allocator/alloc.hpp	/^    static void* reallocate(void *p, size_t old_sz, size_t new_sz);$/;"	p	class:ich::__default_alloc_template	typeref:typename:void *	access:public	signature:(void * p,size_t old_sz,size_t new_sz)
reallocate_map	contains/deque.hpp	/^    void reallocate_map(size_type nodes_to_add, bool add_at_front);$/;"	p	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add,bool add_at_front)
reallocate_map	contains/deque.hpp	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add, bool add_at_front) {$/;"	f	class:ich::deque	typeref:typename:void	signature:(size_type nodes_to_add,bool add_at_front)
rebind	allocator/jj_allocator.hpp	/^    struct rebind$/;"	s	class:JJ::allocator	access:public
reference	allocator/allocator.hpp	/^    typedef T&              reference;$/;"	t	class:ich::allocator	typeref:typename:T &	access:public
reference	allocator/iterator.hpp	/^    typedef Reference   reference;$/;"	t	struct:ich::iterator	typeref:typename:Reference	access:public
reference	allocator/iterator.hpp	/^    typedef T&                          reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:T &	access:public
reference	allocator/iterator.hpp	/^    typedef const T&                    reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:const T &	access:public
reference	allocator/iterator.hpp	/^    typedef typename Iterator::reference            reference;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::reference	access:public
reference	allocator/jj_allocator.hpp	/^    typedef T&              reference;$/;"	t	class:JJ::allocator	typeref:typename:T &	access:public
reference	allocator/std_allocator.hpp	/^    typedef T& reference;$/;"	t	class:allocator	typeref:typename:T &	access:public
reference	contains/deque.hpp	/^    typedef Ref                 reference;$/;"	t	struct:ich::__deque_iterator	typeref:typename:Ref	access:public
reference	contains/deque.hpp	/^    typedef T&          reference;$/;"	t	class:ich::deque	typeref:typename:T &	access:public
reference	contains/hashtable.hpp	/^    typedef Value&                  reference;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value &	access:public
reference	contains/hashtable.hpp	/^    typedef const Value&                  reference;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:const Value &	access:public
reference	contains/hashtable.hpp	/^    typedef value_type& reference;$/;"	t	class:ich::hashtable	typeref:typename:value_type &	access:public
reference	contains/list.hpp	/^    typedef Ref             reference;$/;"	t	struct:ich::__list_iterator	typeref:typename:Ref	access:public
reference	contains/list_temp.hpp	/^    typedef T&                       reference;$/;"	t	class:ich::list	typeref:typename:T &	access:public
reference	contains/list_temp.hpp	/^    typedef T&              reference;$/;"	t	struct:ich::__list_iterator	typeref:typename:T &	access:public
reference	contains/map.hpp	/^    typedef typename rep_type::reference                reference;$/;"	t	class:ich::map	typeref:typename:rep_type::reference	access:public
reference	contains/multimap.hpp	/^    typedef typename rep_type::reference                reference;$/;"	t	class:ich::multimap	typeref:typename:rep_type::reference	access:public
reference	contains/multiset.hpp	/^    typedef typename rep_type::const_reference reference;$/;"	t	class:ich::multiset	typeref:typename:rep_type::const_reference	access:public
reference	contains/queue.hpp	/^    typedef typename Sequence::reference        reference;$/;"	t	class:ich::queue	typeref:typename:Sequence::reference	access:public
reference	contains/rb_tree.hpp	/^    typedef Ref     reference;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Ref	access:public
reference	contains/rb_tree.hpp	/^    typedef value_type&         reference;$/;"	t	class:ich::rb_tree	typeref:typename:value_type &	access:public
reference	contains/set.hpp	/^    typedef typename rep_type::const_reference reference;$/;"	t	class:ich::set	typeref:typename:rep_type::const_reference	access:public
reference	contains/slist.hpp	/^    typedef Ref             reference;$/;"	t	struct:ich::__slist_iterator	typeref:typename:Ref	access:public
reference	contains/slist.hpp	/^    typedef value_type&         reference;$/;"	t	class:ich::slist	typeref:typename:value_type &	access:public
reference	contains/stack.hpp	/^    typedef typename Sequence::reference        reference;$/;"	t	class:ich::stack	typeref:typename:Sequence::reference	access:public
reference	contains/vector.hpp	/^    typedef value_type& reference;$/;"	t	class:ich::vector	typeref:typename:value_type &	access:public
refill	allocator/alloc.hpp	/^    static void* refill(size_t n);$/;"	p	class:ich::__default_alloc_template	typeref:typename:void *	access:private	signature:(size_t n)
refill	allocator/alloc.hpp	/^void* __default_alloc_template<threads, inst>::refill(size_t n) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:void *	signature:(size_t n)
remove	contains/list_temp.hpp	/^    void remove(const T &value) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(const T & value)
rend	contains/map.hpp	/^    const_reverse_iterator rend() const { return t.end(); }$/;"	f	class:ich::map	typeref:typename:const_reverse_iterator	access:public	signature:() const
rend	contains/map.hpp	/^    reverse_iterator rend() { return t.rend(); }$/;"	f	class:ich::map	typeref:typename:reverse_iterator	access:public	signature:()
rend	contains/multimap.hpp	/^    const_reverse_iterator rend() const { return t.end(); }$/;"	f	class:ich::multimap	typeref:typename:const_reverse_iterator	access:public	signature:() const
rend	contains/multimap.hpp	/^    reverse_iterator rend() { return t.rend(); }$/;"	f	class:ich::multimap	typeref:typename:reverse_iterator	access:public	signature:()
rep_iterator	contains/multiset.hpp	/^        typedef typename rep_type::iterator rep_iterator;$/;"	t	function:ich::multiset::erase	typeref:typename:rep_type::iterator
rep_iterator	contains/multiset.hpp	/^        typedef typename rep_type::iterator rep_iterator;$/;"	t	function:ich::multiset::insert	typeref:typename:rep_type::iterator
rep_iterator	contains/set.hpp	/^        typedef typename rep_type::iterator rep_iterator;$/;"	t	function:ich::set::erase	typeref:typename:rep_type::iterator
rep_iterator	contains/set.hpp	/^        typedef typename rep_type::iterator rep_iterator;$/;"	t	function:ich::set::insert	typeref:typename:rep_type::iterator
rep_type	contains/map.hpp	/^    typedef rb_tree<key_type, value_type, select1st<value_type>, key_comp, Alloc> rep_type;$/;"	t	class:ich::map	typeref:typename:rb_tree<key_type,value_type,select1st<value_type>,key_comp,Alloc>	access:private
rep_type	contains/multimap.hpp	/^    typedef rb_tree<key_type, value_type, select1st<value_type>, key_comp, Alloc> rep_type;$/;"	t	class:ich::multimap	typeref:typename:rb_tree<key_type,value_type,select1st<value_type>,key_comp,Alloc>	access:private
rep_type	contains/multiset.hpp	/^    typedef rb_tree<key_type, value_type, identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:ich::multiset	typeref:typename:rb_tree<key_type,value_type,identity<value_type>,key_compare,Alloc>	access:private
rep_type	contains/set.hpp	/^    typedef rb_tree<key_type, value_type, identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:ich::set	typeref:typename:rb_tree<key_type,value_type,identity<value_type>,key_compare,Alloc>	access:private
reserve	contains/vector.hpp	/^    void reserve(size_type n);$/;"	p	class:ich::vector	typeref:typename:void	access:public	signature:(size_type n)
reserve	contains/vector.hpp	/^void vector<T, Alloc>::reserve(size_type n) {$/;"	f	class:ich::vector	typeref:typename:void	signature:(size_type n)
reserve_map_at_bacK	contains/deque.hpp	/^    void reserve_map_at_bacK(size_type nodes_to_add = 1) {$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add=1)
reserve_map_at_front	contains/deque.hpp	/^    void reserve_map_at_front(size_type nodes_to_add = 1) {$/;"	f	class:ich::deque	typeref:typename:void	access:protected	signature:(size_type nodes_to_add=1)
resize	contains/hashtable.hpp	/^    void resize(size_type num_elements_hint);$/;"	p	class:ich::hashtable	typeref:typename:void	access:public	signature:(size_type num_elements_hint)
resize	contains/hashtable.hpp	/^void hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>::resize(size_type num_elements_/;"	f	class:ich::hashtable	typeref:typename:void	signature:(size_type num_elements_hint)
resize	contains/vector.hpp	/^    void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(size_type new_size)
resize	contains/vector.hpp	/^    void resize(size_type new_size, const T &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(size_type new_size,const T & x)
reverse_iterator	contains/map.hpp	/^    typedef typename rep_type::reverse_iterator         reverse_iterator;$/;"	t	class:ich::map	typeref:typename:rep_type::reverse_iterator	access:public
reverse_iterator	contains/multimap.hpp	/^    typedef typename rep_type::reverse_iterator         reverse_iterator;$/;"	t	class:ich::multimap	typeref:typename:rep_type::reverse_iterator	access:public
right	contains/rb_tree.hpp	/^    base_ptr    right;$/;"	m	struct:ich::__rb_tree_node_base	typeref:typename:base_ptr	access:public
right	contains/rb_tree.hpp	/^    static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(base_ptr x)
right	contains/rb_tree.hpp	/^    static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:(link_type x)
rightmost	contains/rb_tree.hpp	/^    link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
root	contains/rb_tree.hpp	/^    link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:ich::rb_tree	typeref:typename:link_type &	access:protected	signature:() const
round_up	allocator/alloc.hpp	/^    static size_t round_up(size_t bytes) {$/;"	f	class:ich::__default_alloc_template	typeref:typename:size_t	access:private	signature:(size_t bytes)
second	contains/pair.hpp	/^    T2 second;$/;"	m	struct:ich::pair	typeref:typename:T2	access:public
second_type	contains/pair.hpp	/^    typedef T2 second_type;$/;"	t	struct:ich::pair	typeref:typename:T2	access:public
self	contains/deque.hpp	/^    typedef __deque_iterator<T, Ref, Ptr, BufSiz>           self;$/;"	t	struct:ich::__deque_iterator	typeref:typename:__deque_iterator<T,Ref,Ptr,BufSiz>	access:public
self	contains/list.hpp	/^    typedef __list_iterator<T, Ref, Ptr>    self;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T,Ref,Ptr>	access:public
self	contains/list_temp.hpp	/^    typedef __list_iterator<T> self;$/;"	t	struct:ich::__list_iterator	typeref:typename:__list_iterator<T>	access:public
self	contains/rb_tree.hpp	/^    typedef __rb_tree_iterator<Value, Ref, Ptr>                     self;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:__rb_tree_iterator<Value,Ref,Ptr>	access:public
self	contains/slist.hpp	/^    typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:ich::__slist_iterator	typeref:typename:__slist_iterator<T,Ref,Ptr>	access:public
set	contains/set.hpp	/^    explicit set(const Compare &comp) : t(comp) {}$/;"	f	class:ich::set	access:public	signature:(const Compare & comp)
set	contains/set.hpp	/^    set() : t(Compare()) {}$/;"	f	class:ich::set	access:public	signature:()
set	contains/set.hpp	/^    set(InputIterator first, InputIterator last) : t(Compare()) { t.insert_unique(first, last); /;"	f	class:ich::set	access:public	signature:(InputIterator first,InputIterator last)
set	contains/set.hpp	/^    set(InputIterator first, InputIterator last, const Compare &comp) : t(comp) { t.insert_uniqu/;"	f	class:ich::set	access:public	signature:(InputIterator first,InputIterator last,const Compare & comp)
set	contains/set.hpp	/^    set(const set<Key, Compare, Alloc> &x) : t(x.t) {}$/;"	f	class:ich::set	access:public	signature:(const set<Key,Compare,Alloc> & x)
set	contains/set.hpp	/^class set {$/;"	c	namespace:ich
set_malloc_handler	allocator/alloc.hpp	/^    static void (*set_malloc_handler(void (* f)())) ()$/;"	f	class:ich::__malloc_alloc_template	typeref:typename:void (*)()	access:public	signature:(void (* f)())
set_node	contains/deque.hpp	/^    void set_node(map_pointer new_node) {$/;"	f	struct:ich::__deque_iterator	typeref:typename:void	access:public	signature:(map_pointer new_node)
set_test	contains/test.cpp	/^void set_test() {$/;"	f	typeref:typename:void	signature:()
size	contains/deque.hpp	/^    size_type size() const { return finish - start; }   \/\/ iterator::operator-$/;"	f	class:ich::deque	typeref:typename:size_type	access:public	signature:() const
size	contains/hashtable.hpp	/^    size_type size() const { return num_elements; }$/;"	f	class:ich::hashtable	typeref:typename:size_type	access:public	signature:() const
size	contains/list_temp.hpp	/^    size_type size() {$/;"	f	class:ich::list	typeref:typename:size_type	access:public	signature:()
size	contains/map.hpp	/^    size_type size() const { return t.empty(); }$/;"	f	class:ich::map	typeref:typename:size_type	access:public	signature:() const
size	contains/multimap.hpp	/^    size_type size() const { return t.empty(); }$/;"	f	class:ich::multimap	typeref:typename:size_type	access:public	signature:() const
size	contains/multiset.hpp	/^    size_type size() const { return t.size(); }$/;"	f	class:ich::multiset	typeref:typename:size_type	access:public	signature:() const
size	contains/queue.hpp	/^    size_type size() const { return c.size(); }$/;"	f	class:ich::queue	typeref:typename:size_type	access:public	signature:() const
size	contains/rb_tree.hpp	/^    size_type size() const { return node_count; }$/;"	f	class:ich::rb_tree	typeref:typename:size_type	access:public	signature:() const
size	contains/set.hpp	/^    size_type size() const { return t.size(); }$/;"	f	class:ich::set	typeref:typename:size_type	access:public	signature:() const
size	contains/slist.hpp	/^    size_type size() const { return  __slist_size(head.next); }$/;"	f	class:ich::slist	typeref:typename:size_type	access:public	signature:() const
size	contains/stack.hpp	/^    size_type size() const { return c.size(); }$/;"	f	class:ich::stack	typeref:typename:size_type	access:public	signature:() const
size	contains/vector.hpp	/^    size_type size() const { return size_type(cend() - cbegin()); }$/;"	f	class:ich::vector	typeref:typename:size_type	access:public	signature:() const
size_tyep	allocator/std_allocator.hpp	/^    typedef size_t size_tyep;$/;"	t	class:allocator	typeref:typename:size_t	access:public
size_type	allocator/allocator.hpp	/^    typedef std::size_t     size_type;$/;"	t	class:ich::allocator	typeref:typename:std::size_t	access:public
size_type	allocator/jj_allocator.hpp	/^    typedef std::size_t     size_type;$/;"	t	class:JJ::allocator	typeref:typename:std::size_t	access:public
size_type	contains/deque.hpp	/^    typedef size_t              size_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:size_t	access:public
size_type	contains/deque.hpp	/^    typedef size_t      size_type;$/;"	t	class:ich::deque	typeref:typename:size_t	access:public
size_type	contains/hashtable.hpp	/^    typedef size_t                  size_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:size_t	access:public
size_type	contains/hashtable.hpp	/^    typedef size_t                  size_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:size_t	access:public
size_type	contains/hashtable.hpp	/^    typedef size_t size_type;$/;"	t	class:ich::hashtable	typeref:typename:size_t	access:public
size_type	contains/list.hpp	/^    typedef size_t          size_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:size_t	access:public
size_type	contains/list_temp.hpp	/^    typedef size_t                   size_type;$/;"	t	class:ich::list	typeref:typename:size_t	access:public
size_type	contains/list_temp.hpp	/^    typedef size_t          size_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:size_t	access:public
size_type	contains/map.hpp	/^    typedef typename rep_type::size_type                size_type;$/;"	t	class:ich::map	typeref:typename:rep_type::size_type	access:public
size_type	contains/multimap.hpp	/^    typedef typename rep_type::size_type                size_type;$/;"	t	class:ich::multimap	typeref:typename:rep_type::size_type	access:public
size_type	contains/multiset.hpp	/^    typedef typename rep_type::size_type size_type;$/;"	t	class:ich::multiset	typeref:typename:rep_type::size_type	access:public
size_type	contains/queue.hpp	/^    typedef typename Sequence::size_type        size_type;$/;"	t	class:ich::queue	typeref:typename:Sequence::size_type	access:public
size_type	contains/rb_tree.hpp	/^    typedef size_t              size_type;$/;"	t	class:ich::rb_tree	typeref:typename:size_t	access:public
size_type	contains/set.hpp	/^    typedef typename rep_type::size_type size_type;$/;"	t	class:ich::set	typeref:typename:rep_type::size_type	access:public
size_type	contains/slist.hpp	/^    typedef size_t              size_type;$/;"	t	class:ich::slist	typeref:typename:size_t	access:public
size_type	contains/slist.hpp	/^    typedef size_t      size_type;$/;"	t	struct:ich::__slist_iterator_base	typeref:typename:size_t	access:public
size_type	contains/stack.hpp	/^    typedef typename Sequence::size_type        size_type;$/;"	t	class:ich::stack	typeref:typename:Sequence::size_type	access:public
size_type	contains/vector.hpp	/^    typedef size_t      size_type;$/;"	t	class:ich::vector	typeref:typename:size_t	access:public
slist	contains/slist.hpp	/^    slist() { head.next = 0; }$/;"	f	class:ich::slist	access:public	signature:()
slist	contains/slist.hpp	/^class slist$/;"	c	namespace:ich
slist_test	contains/test.cpp	/^void slist_test() {$/;"	f	typeref:typename:void	signature:()
sort_heap	contains/algorithm.hpp	/^inline void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f	namespace:ich	typeref:typename:void	signature:(RandomAccessIterator first,RandomAccessIterator last)
splice	contains/list_temp.hpp	/^    void splice(iterator position, list &, iterator i) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(iterator position,list &,iterator i)
splice	contains/list_temp.hpp	/^    void splice(iterator position, list &x) {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:(iterator position,list & x)
stack	confusing_syntax/some_confusing_syntax.cpp	/^    stack() { std::cout << "stack" << std::endl; }$/;"	f	class:stack	file:	access:public	signature:()
stack	confusing_syntax/some_confusing_syntax.cpp	/^class stack {$/;"	c	file:
stack	contains/stack.hpp	/^class stack {$/;"	c	namespace:ich
stack::c	confusing_syntax/some_confusing_syntax.cpp	/^    Sequence c;$/;"	m	class:stack	typeref:typename:Sequence	file:	access:private
stack::stack	confusing_syntax/some_confusing_syntax.cpp	/^    stack() { std::cout << "stack" << std::endl; }$/;"	f	class:stack	file:	access:public	signature:()
stack_test	contains/test.cpp	/^void stack_test() {$/;"	f	typeref:typename:void	signature:()
start	contains/deque.hpp	/^    iterator start;$/;"	m	class:ich::deque	typeref:typename:iterator	access:protected
start	contains/vector.hpp	/^    iterator start;$/;"	m	class:ich::vector	typeref:typename:iterator	access:protected
start_free	allocator/alloc.hpp	/^    static char *start_free;    \/\/ 内存池开始位置$/;"	m	class:ich::__default_alloc_template	typeref:typename:char *	access:private
start_free	allocator/alloc.hpp	/^char* __default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:ich::__default_alloc_template<threads, inst>	typeref:typename:char *
swap	confusing_syntax/some_confusing_syntax.cpp	/^    void swap(vector<T, Alloc> &)$/;"	f	class:vector	typeref:typename:void	file:	access:public	signature:(vector<T,Alloc> &)
swap	confusing_syntax/some_confusing_syntax.cpp	/^inline void swap(vector<T, Alloc> &x, vector<T, Alloc> &y) {$/;"	f	typeref:typename:void	signature:(vector<T,Alloc> & x,vector<T,Alloc> & y)
swap	contains/algorithm.hpp	/^void swap(T1 &left, T2 &right) {$/;"	f	namespace:ich	typeref:typename:void	signature:(T1 & left,T2 & right)
swap	contains/hashtable.hpp	/^    void swap(hashtable &ht) {$/;"	f	class:ich::hashtable	typeref:typename:void	access:public	signature:(hashtable & ht)
swap	contains/map.hpp	/^    void swap(map<Key, T, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::map	typeref:typename:void	access:public	signature:(map<Key,T,Compare,Alloc> & x)
swap	contains/multimap.hpp	/^    void swap(multimap<Key, T, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::multimap	typeref:typename:void	access:public	signature:(multimap<Key,T,Compare,Alloc> & x)
swap	contains/multiset.hpp	/^    void swap(multiset<Key, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::multiset	typeref:typename:void	access:public	signature:(multiset<Key,Compare,Alloc> & x)
swap	contains/set.hpp	/^    void swap(set<Key, Compare, Alloc> &x) { t.swap(x.t); }$/;"	f	class:ich::set	typeref:typename:void	access:public	signature:(set<Key,Compare,Alloc> & x)
swap	contains/slist.hpp	/^    void swap(slist &L) {$/;"	f	class:ich::slist	typeref:typename:void	access:public	signature:(slist & L)
swap	contains/vector.hpp	/^    void swap(vector<T, Alloc> &x) {$/;"	f	class:ich::vector	typeref:typename:void	access:public	signature:(vector<T,Alloc> & x)
t	contains/map.hpp	/^    rep_type t;$/;"	m	class:ich::map	typeref:typename:rep_type	access:private
t	contains/multimap.hpp	/^    rep_type t;$/;"	m	class:ich::multimap	typeref:typename:rep_type	access:private
t	contains/multiset.hpp	/^    rep_type t; \/\/ 用红黑树来表现multiset$/;"	m	class:ich::multiset	typeref:typename:rep_type	access:private
t	contains/set.hpp	/^    rep_type t; \/\/ 用红黑树来表现set$/;"	m	class:ich::set	typeref:typename:rep_type	access:private
this_dummy_member_must_be_first	allocator/__type_traits.hpp	/^    typedef __true_type this_dummy_member_must_be_first;$/;"	t	struct:ich::__type_traits	typeref:typename:__true_type	access:public
top	contains/stack.hpp	/^    reference top() { return c.back(); }$/;"	f	class:ich::stack	typeref:typename:reference	access:public	signature:()
transfer	contains/list_temp.hpp	/^    void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:ich::list	typeref:typename:void	access:protected	signature:(iterator position,iterator first,iterator last)
trivial_destructor	allocator/constructor.hpp	/^    typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;$/;"	t	function:ich::__destroy	typeref:typename:__type_traits<T>::has_trivial_destructor
type_value	allocator/std_allocator.hpp	/^    typedef T type_value;$/;"	t	class:allocator	typeref:typename:T	access:public
uninitialized_copy	allocator/uninitialized.hpp	/^ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator resu/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(InputIterator first,InputIterator last,ForwardIterator result)
uninitialized_copy	allocator/uninitialized.hpp	/^inline char* uninitialized_copy(const char *first, const char *last, char *result) {$/;"	f	namespace:ich	typeref:typename:char *	signature:(const char * first,const char * last,char * result)
uninitialized_copy	allocator/uninitialized.hpp	/^inline wchar_t* uninitialized_copy(const wchar_t *first, const wchar_t *last, wchar_t *result) {$/;"	f	namespace:ich	typeref:typename:wchar_t *	signature:(const wchar_t * first,const wchar_t * last,wchar_t * result)
uninitialized_fill	allocator/uninitialized.hpp	/^void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &x) {$/;"	f	namespace:ich	typeref:typename:void	signature:(ForwardIterator first,ForwardIterator last,const T & x)
uninitialized_fill_n	allocator/uninitialized.hpp	/^inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T &x) {$/;"	f	namespace:ich	typeref:typename:ForwardIterator	signature:(ForwardIterator first,Size n,const T & x)
unique	contains/list_temp.hpp	/^    void unique() {$/;"	f	class:ich::list	typeref:typename:void	access:public	signature:()
upper_bound	contains/map.hpp	/^    const_iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::map	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
upper_bound	contains/map.hpp	/^    iterator upper_bound(const key_type &x) { return t.upper_bound(x); }$/;"	f	class:ich::map	typeref:typename:iterator	access:public	signature:(const key_type & x)
upper_bound	contains/multimap.hpp	/^    const_iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:const_iterator	access:public	signature:(const key_type & x) const
upper_bound	contains/multimap.hpp	/^    iterator upper_bound(const key_type &x) { return t.upper_bound(x); }$/;"	f	class:ich::multimap	typeref:typename:iterator	access:public	signature:(const key_type & x)
upper_bound	contains/multiset.hpp	/^    iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::multiset	typeref:typename:iterator	access:public	signature:(const key_type & x) const
upper_bound	contains/rb_tree.hpp	/^    const_iterator upper_bound(const Key &k) const;$/;"	p	class:ich::rb_tree	typeref:typename:const_iterator	access:public	signature:(const Key & k) const
upper_bound	contains/rb_tree.hpp	/^    iterator upper_bound(const Key &k);$/;"	p	class:ich::rb_tree	typeref:typename:iterator	access:public	signature:(const Key & k)
upper_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key &k) const {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::const_iterator	signature:(const Key & k) const
upper_bound	contains/rb_tree.hpp	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key &k) {$/;"	f	class:ich::rb_tree	typeref:typename:rb_tree<Key,Value,KeyOfValue,Compare,Alloc>::iterator	signature:(const Key & k)
upper_bound	contains/set.hpp	/^    iterator upper_bound(const key_type &x) const { return t.upper_bound(x); }$/;"	f	class:ich::set	typeref:typename:iterator	access:public	signature:(const key_type & x) const
val	contains/hashtable.hpp	/^    Value val;$/;"	m	struct:ich::__hashtable_node	typeref:typename:Value	access:public
value	contains/rb_tree.hpp	/^    static reference value(base_ptr x) { return link_type(x)->value_field; }$/;"	f	class:ich::rb_tree	typeref:typename:reference	access:protected	signature:(base_ptr x)
value	contains/rb_tree.hpp	/^    static reference value(link_type x) { return x->value_field; }$/;"	f	class:ich::rb_tree	typeref:typename:reference	access:protected	signature:(link_type x)
value_comp	contains/map.hpp	/^    value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:ich::map	typeref:typename:value_compare	access:public	signature:() const
value_comp	contains/multimap.hpp	/^    value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:ich::multimap	typeref:typename:value_compare	access:public	signature:() const
value_comp	contains/multiset.hpp	/^    value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:ich::multiset	typeref:typename:value_compare	access:public	signature:() const
value_comp	contains/set.hpp	/^    value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:ich::set	typeref:typename:value_compare	access:public	signature:() const
value_compare	contains/map.hpp	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:ich::map::value_compare	access:protected	signature:(Compare c)
value_compare	contains/map.hpp	/^    class value_compare : public std::binary_function<value_type, value_type, bool> {$/;"	c	class:ich::map	inherits:std::binary_function<value_type,value_type,bool>	access:public
value_compare	contains/multimap.hpp	/^        value_compare(Compare c) : comp(c) {}$/;"	f	class:ich::multimap::value_compare	access:protected	signature:(Compare c)
value_compare	contains/multimap.hpp	/^    class value_compare : public std::binary_function<value_type, value_type, bool> {$/;"	c	class:ich::multimap	inherits:std::binary_function<value_type,value_type,bool>	access:public
value_compare	contains/multiset.hpp	/^    typedef Compare value_compare;$/;"	t	class:ich::multiset	typeref:typename:Compare	access:public
value_compare	contains/set.hpp	/^    typedef Compare value_compare;$/;"	t	class:ich::set	typeref:typename:Compare	access:public
value_field	contains/rb_tree.hpp	/^    Value value_field; \/\/ 节点值$/;"	m	struct:ich::__rb_tree_node	typeref:typename:Value	access:public
value_type	allocator/allocator.hpp	/^    typedef T               value_type;$/;"	t	class:ich::allocator	typeref:typename:T	access:public
value_type	allocator/iterator.hpp	/^    typedef T                           value_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:T	access:public
value_type	allocator/iterator.hpp	/^    typedef T           value_type;$/;"	t	struct:ich::iterator	typeref:typename:T	access:public
value_type	allocator/iterator.hpp	/^    typedef typename Iterator::value_type           value_type;$/;"	t	struct:ich::iterator_traits	typeref:typename:Iterator::value_type	access:public
value_type	allocator/iterator.hpp	/^inline typename iterator_traits<Iterator>::value_type* value_type(const Iterator&) {$/;"	f	namespace:ich	typeref:typename:iterator_traits<Iterator>::value_type *	signature:(const Iterator &)
value_type	allocator/jj_allocator.hpp	/^    typedef T               value_type;$/;"	t	class:JJ::allocator	typeref:typename:T	access:public
value_type	allocator/test.cpp	/^    typedef T value_type;$/;"	t	struct:MyIter	typeref:typename:T	file:	access:public
value_type	allocator/test.cpp	/^    typedef T value_type;$/;"	t	struct:iterator_traits	typeref:typename:T	file:	access:public
value_type	allocator/test.cpp	/^    typedef typename I::value_type value_type;$/;"	t	struct:iterator_traits	typeref:typename:I::value_type	file:	access:public
value_type	confusing_syntax/some_confusing_syntax.cpp	/^    typedef T value_type;$/;"	t	class:vector	typeref:typename:T	file:	access:public
value_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::value_type* value_type;$/;"	t	function:ich::make_heap	typeref:typename:iterator_traits<RandomAccessIterator>::value_type *
value_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::value_type* value_type;$/;"	t	function:ich::pop_heap	typeref:typename:iterator_traits<RandomAccessIterator>::value_type *
value_type	contains/algorithm.hpp	/^    typedef typename iterator_traits<RandomAccessIterator>::value_type* value_type;$/;"	t	function:ich::push_heap	typeref:typename:iterator_traits<RandomAccessIterator>::value_type *
value_type	contains/deque.hpp	/^    typedef T                   value_type;$/;"	t	struct:ich::__deque_iterator	typeref:typename:T	access:public
value_type	contains/deque.hpp	/^    typedef T           value_type;$/;"	t	class:ich::deque	typeref:typename:T	access:public
value_type	contains/hashtable.hpp	/^    typedef Value                   value_type;$/;"	t	struct:ich::__hashtable_const_iterator	typeref:typename:Value	access:public
value_type	contains/hashtable.hpp	/^    typedef Value                   value_type;$/;"	t	struct:ich::__hashtable_iterator	typeref:typename:Value	access:public
value_type	contains/hashtable.hpp	/^    typedef Value value_type;$/;"	t	class:ich::hashtable	typeref:typename:Value	access:public
value_type	contains/list.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:T	access:public
value_type	contains/list_temp.hpp	/^    typedef T                        value_type;$/;"	t	class:ich::list	typeref:typename:T	access:public
value_type	contains/list_temp.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__list_iterator	typeref:typename:T	access:public
value_type	contains/map.hpp	/^    typedef ich::pair<const Key, T> value_type;$/;"	t	class:ich::map	typeref:typename:ich::pair<const Key,T>	access:public
value_type	contains/multimap.hpp	/^    typedef ich::pair<const Key, T> value_type;$/;"	t	class:ich::multimap	typeref:typename:ich::pair<const Key,T>	access:public
value_type	contains/multiset.hpp	/^    typedef Key value_type;$/;"	t	class:ich::multiset	typeref:typename:Key	access:public
value_type	contains/queue.hpp	/^    typedef typename Sequence::value_type       value_type;$/;"	t	class:ich::queue	typeref:typename:Sequence::value_type	access:public
value_type	contains/rb_tree.hpp	/^    typedef Value               value_type;$/;"	t	class:ich::rb_tree	typeref:typename:Value	access:public
value_type	contains/rb_tree.hpp	/^    typedef Value   value_type;$/;"	t	struct:ich::__rb_tree_iterator	typeref:typename:Value	access:public
value_type	contains/set.hpp	/^    typedef Key value_type;$/;"	t	class:ich::set	typeref:typename:Key	access:public
value_type	contains/slist.hpp	/^    typedef T                   value_type;$/;"	t	class:ich::slist	typeref:typename:T	access:public
value_type	contains/slist.hpp	/^    typedef T               value_type;$/;"	t	struct:ich::__slist_iterator	typeref:typename:T	access:public
value_type	contains/stack.hpp	/^    typedef typename Sequence::value_type       value_type;$/;"	t	class:ich::stack	typeref:typename:Sequence::value_type	access:public
value_type	contains/vector.hpp	/^    typedef T           value_type;$/;"	t	class:ich::vector	typeref:typename:T	access:public
vecotr_test	contains/test.cpp	/^void vecotr_test() {$/;"	f	typeref:typename:void	signature:()
vector	confusing_syntax/some_confusing_syntax.cpp	/^class vector {$/;"	c	file:
vector	contains/vector.hpp	/^    explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:ich::vector	access:public	signature:(size_type n)
vector	contains/vector.hpp	/^    vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:ich::vector	access:public	signature:()
vector	contains/vector.hpp	/^    vector(int n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(int n,const T & value)
vector	contains/vector.hpp	/^    vector(iterator first, iterator last) { fill_initialize(first, last); }$/;"	f	class:ich::vector	access:public	signature:(iterator first,iterator last)
vector	contains/vector.hpp	/^    vector(long n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(long n,const T & value)
vector	contains/vector.hpp	/^    vector(size_type n, const T &value) { fill_initialize(n, value); }$/;"	f	class:ich::vector	access:public	signature:(size_type n,const T & value)
vector	contains/vector.hpp	/^class vector {$/;"	c	namespace:ich
vector::_data	confusing_syntax/some_confusing_syntax.cpp	/^    static int _data;$/;"	m	class:vector	typeref:typename:int	file:	access:public
vector::insert	confusing_syntax/some_confusing_syntax.cpp	/^    void insert(iterator position, I first, I last) {$/;"	f	class:vector	typeref:typename:void	file:	access:public	signature:(iterator position,I first,I last)
vector::iterator	confusing_syntax/some_confusing_syntax.cpp	/^    typedef value_type *iterator;$/;"	t	class:vector	typeref:typename:value_type *	file:	access:public
vector::swap	confusing_syntax/some_confusing_syntax.cpp	/^    void swap(vector<T, Alloc> &)$/;"	f	class:vector	typeref:typename:void	file:	access:public	signature:(vector<T,Alloc> &)
vector::value_type	confusing_syntax/some_confusing_syntax.cpp	/^    typedef T value_type;$/;"	t	class:vector	typeref:typename:T	file:	access:public
vector<char>::_data	confusing_syntax/some_confusing_syntax.cpp	/^template<> int vector<char>::_data = 2;$/;"	m	class:vector<char>	typeref:typename:int
vector<int>::_data	confusing_syntax/some_confusing_syntax.cpp	/^template<> int vector<int>::_data = 1;$/;"	m	class:vector<int>	typeref:typename:int
void_pointer	contains/list.hpp	/^    typedef void *void_pointer;$/;"	t	struct:ich::__list_node	typeref:typename:void *	access:public
void_pointer	contains/list_temp.hpp	/^    typedef void *void_pointer;$/;"	t	struct:ich::__list_node	typeref:typename:void *	access:public
void_pointer	contains/rb_tree.hpp	/^    typedef void*                   void_pointer;$/;"	t	class:ich::rb_tree	typeref:typename:void *	access:protected
what	allocator/test.cpp	/^void what()$/;"	f	typeref:typename:void	signature:()
whatthefuck	allocator/jj_allocator.hpp	/^void whatthefuck()$/;"	f	namespace:JJ	typeref:typename:void	signature:()
~hashtable	contains/hashtable.hpp	/^    ~hashtable() { clear(); }$/;"	f	class:ich::hashtable	access:public	signature:()
~rb_tree	contains/rb_tree.hpp	/^    ~rb_tree() { clear(); put_node(header); }$/;"	f	class:ich::rb_tree	access:public	signature:()
~slist	contains/slist.hpp	/^    ~slist() { clear(); }$/;"	f	class:ich::slist	access:public	signature:()
~vector	contains/vector.hpp	/^    ~vector() {$/;"	f	class:ich::vector	access:public	signature:()
